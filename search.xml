<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode刷题笔记——反转链表</title>
    <url>/2021/01/31/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>&emsp;&emsp;定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<br><span id="more"></span></p>
<p>示例:</p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre><p>0 &lt;= 节点个数 &lt;= 5000</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;此题很明显时间复杂度不会超过O(n),如果新建一个链表进行头插，那么空间复杂度为O(n)。现思考有没有空间复杂度为O(1)的解法，即在原本的链表基础上进行改动。</p>
<p>&emsp;&emsp;设定双指针pre和cur用于交换。而next作为中间指针保存cur.next的信息。算法图示如下：<br><img src="https://tva1.sinaimg.cn/large/0083jUChgy1gn6xc46di9j30qt0j60uz.jpg" alt="avatar"></p>
<p>具体代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        ListNode *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此题为大厂常考题目，建议熟记于心。</p>
]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-2-最长回文子串</title>
    <url>/2021/01/28/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<h1 id="最长回文子串-TENET"><a href="#最长回文子串-TENET" class="headerlink" title="最长回文子串(TENET)"></a>最长回文子串(TENET)</h1><p>&emsp;&emsp;题目描述：给你一个字符串 s，找到 s 中最长的回文子串。<span id="more"></span>1 &lt;= s.length &lt;= 1000且 s 仅由数字和英文字母（大写和/或小写）组成。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;看到题目的第一眼不难想到暴力解法，如果字符串长度为t的话，那么从头到尾遍历所有的字符串时间复杂度为O($t^2$),而此情况下判断字符串是否回文的最小时间复杂度为O($t$),所以总时间复杂度为O($t^3$),由于y最大为1000，因此此方法超时。<br>&emsp;&emsp;之后想到一种去除冗余遍历的方式，如果以字符串元素s[i]为中点，然后以中点向外发散式的遍历字符串。这样遍历有一种好处，那就是如果扩散到外围某个元素发现此时不回文了，那么此时可以中止向外扩散。<br>&emsp;&emsp;但是有一个问题，中心扩散有两种方式。若用mid指代中心元素位置，一种有奇数个元素，即mid在字符串正中间。第二种是有偶数个元素，那么mid处于中心偏右或者中心偏左的位置。因此要分情况讨论，下面我们默认mid只能处于中心偏右。<br>&emsp;&emsp;采用了这种算法后，对于是否回文的判断也简化了，对于同一个mid，是否回文只需判断最外圈层的元素是否对称，即时间复杂度为O(1),总时间复杂度降为O($n^2$)了。<br>具体代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><span class="comment">//时间复杂度O(n^2)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Ishuiwen</span><span class="params">(string x)</span></span>&#123;<span class="comment">//此函数用于判断字符串是否回文</span></span><br><span class="line">        <span class="keyword">if</span>(x[<span class="number">0</span>]==x[x.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用中心扩散法来减少计算量</span></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;<span class="comment">//中心元素</span></span><br><span class="line">        <span class="keyword">int</span> front;<span class="comment">//扩散字符串的头指针</span></span><br><span class="line">        <span class="keyword">int</span> halflength;<span class="comment">//由于是中心扩散，所以定义一个半长</span></span><br><span class="line">        <span class="keyword">int</span> length;<span class="comment">//当前遍历字符串总长度</span></span><br><span class="line">        string ans=s.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//答案字符串</span></span><br><span class="line">        <span class="keyword">int</span> anslength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(mid = <span class="number">0</span>;mid&lt;s.<span class="built_in">size</span>();mid++)&#123;</span><br><span class="line">            halflength = <span class="number">0</span>;</span><br><span class="line">            front = mid;</span><br><span class="line">            length = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">Ishuiwen</span>(s.<span class="built_in">substr</span>(front,length)))&#123;<span class="comment">//第一种情况，以mid为中心</span></span><br><span class="line">                front = mid-halflength;</span><br><span class="line">                length = <span class="number">2</span>*halflength+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[front]==s[front+length<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(length&gt;anslength)&#123;</span><br><span class="line">                        ans = s.<span class="built_in">substr</span>(front, length);</span><br><span class="line">                        anslength = length;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">break</span>;</span><br><span class="line">                halflength++;</span><br><span class="line">            &#125;</span><br><span class="line">            halflength = <span class="number">0</span>;</span><br><span class="line">            front = mid;</span><br><span class="line">            length = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">Ishuiwen</span>(s.<span class="built_in">substr</span>(front,length)))&#123;<span class="comment">//第二种情况，mid为中心右侧</span></span><br><span class="line">                front = mid-halflength<span class="number">-1</span>;</span><br><span class="line">                length = <span class="number">2</span>*(halflength+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(s[front]==s[front+length<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(length&gt;anslength)&#123;</span><br><span class="line">                        ans = s.<span class="built_in">substr</span>(front, length);</span><br><span class="line">                        anslength = length;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">break</span>;</span><br><span class="line">                halflength++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然而此发超时，因此还需进一步去除代码冗余，后经分析得知，判断时候冗余的函数 bool Ishuiwen(string x) 可以直接用一个判断语句代替。  </p>
<pre><code>if(s[front]==s[front+length-1])
</code></pre><p>&emsp;&emsp;再次运行代码没有超时。此题还可以用动态规划的方法，目前未掌握。</p>
]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>DP动态规划算法</title>
    <url>/2021/01/28/DP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h2 id="一、动态规划简介"><a href="#一、动态规划简介" class="headerlink" title="一、动态规划简介"></a>一、动态规划简介</h2><p>&emsp;&emsp;与分治法类似，即将待求解问题分解为若干子问题，先求解子问题，再由子问题的解得到原问题的解。<span id="more"></span>与分治法不同，它可以通过保存已解决子问题的答案来避免重复计算。加上记忆化之后相当于牺牲了一定的空间复杂度来换取时间复杂度。</p>
<script type="math/tex; mode=display">动态规划\left\{
\begin{matrix}
 递推求解 \\
 最大连续子序列和\\
 最大递增子序列和\\
 最大公共子序列\\
 背包问题 
\end{matrix}
\right.</script><p>动态规划两种方法：</p>
<p>1.递归策略+记忆法 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;  2.递推求解<br>（注：代码中最好不要出现递归，递归可能导致代码执行偏慢）</p>
<h2 id="一、最大连续子序列和"><a href="#一、最大连续子序列和" class="headerlink" title="一、最大连续子序列和"></a>一、最大连续子序列和</h2><p><strong>eg1.</strong> 给出一个整数序列S，其中有N个数，定义其中一个非空连续子序列T中所有数的和为T的“序列和”。 对于S的所有非空连续子序列T，求最大的序列和。 变量条件：N为正整数，N≤1000000，结果序列和在范围（-$2^ (63)$,$2^ (63)$-1）以内。</p>
<p>&emsp;&emsp;题目分析：本题如果采用最暴力的解法，即不固定子字符串首位，则遍历所有子序列的时间复杂度为O($n^2$)，求序列和的时间复杂度为O($n$)，总时间复杂度为O($n^3$).如果固定子序列尾部采用递归的手段，时间复杂度为O($n^2$)。<br>如果在递归的基础上加上记忆法，即动态规划的方法，时间复杂度可以降到O($n$)。同理，可以将此递归+记忆法的方法改变成递推求解。题目还有一个易错点即变量类型，可以由序列和的范围知最好采用long long型。<br>&emsp;&emsp;递推求解的代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MINN = <span class="number">-1e6</span><span class="number">-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> arr[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[MAXN];<span class="comment">//记录以输入每个元素结尾的最大字符和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> maximum = MINN;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span>)	dp[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span>    dp[i]  = <span class="built_in">max</span>(arr[i],dp[i<span class="number">-1</span>]+arr[i]);</span><br><span class="line">		maximum =<span class="built_in">max</span>(maximum,dp[i]); <span class="comment">//对递归求解的优化部分</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maximum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;arr[i]);</span><br><span class="line">		&#125;<span class="comment">//输入参数模块，基操</span></span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="built_in">func</span>(n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一、最大连续子序列和-1"><a href="#一、最大连续子序列和-1" class="headerlink" title="一、最大连续子序列和"></a>一、最大连续子序列和</h2>]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记——寻找两个正序数的中位数</title>
    <url>/2021/02/02/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>&emsp;&emsp;给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。<br><span id="more"></span></p>
<p>示例 1：</p>
<pre><code>输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
</code></pre><p>示例 2：</p>
<pre><code>输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
</code></pre><p>示例 3：</p>
<pre><code>输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
</code></pre><p>示例 4：</p>
<pre><code>输入：nums1 = [], nums2 = [1]
输出：1.00000
</code></pre><p>示例 5：</p>
<pre><code>输入：nums1 = [2], nums2 = []
输出：2.00000
</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a></p>
<p>提示：</p>
<pre><code>nums1.length == m
nums2.length == n
0 &lt;= m &lt;= 1000
0 &lt;= n &lt;= 1000
1 &lt;= m + n &lt;= 2000
-106 &lt;= nums1[i], nums2[i] &lt;= 106
</code></pre><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;此题很明显时间复杂度不会超过O(n),如果新建一个链表进行头插，那么空间复杂度为O(n)。现思考有没有空间复杂度为O(1)的解法，即在原本的链表基础上进行改动。</p>
<p>&emsp;&emsp;设定双指针pre和cur用于交换。而next作为中间指针保存cur.next的信息。算法图示如下：<br><img src="" alt="avatar"></p>
<p>具体代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        ListNode *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此题为大厂常考题目，建议熟记于心。</p>
]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>重配爵士和声教程（一）</title>
    <url>/2021/01/28/%E9%87%8D%E9%85%8D%E5%92%8C%E5%A3%B0%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="如何重配和声（笔记）"><a href="#如何重配和声（笔记）" class="headerlink" title="如何重配和声（笔记）"></a>如何重配和声（笔记）</h1><p>注：重配和声  =  和弦替代</p>
<p>重配和声被用于：<span id="more"></span></p>
<ul>
<li>让一首歌爵士化，即丰富其和声，让它的结构复杂</li>
<li>使歌曲更富有个人色彩</li>
</ul>
<p>歌曲的普遍结构=旋律线 + 和声进行，重配和声包括改变歌曲的旋律线和和声，此改变要基于一定的规则和概念。</p>
<h2 id="重配和声分为以下两个方面："><a href="#重配和声分为以下两个方面：" class="headerlink" title="重配和声分为以下两个方面："></a>重配和声分为以下两个方面：</h2><ol>
<li>和弦<ol>
<li>旋律和和弦之间相互作用要合理</li>
<li>取决于和弦的种类</li>
<li>基音必须是所选和弦中的一个可用音</li>
</ol>
</li>
<li>结构（包括和弦结构和低音线条）<ol>
<li>不受和弦种类的影响</li>
<li>结构必须合理   </li>
</ol>
</li>
</ol>
<p><strong>重配和弦的步骤</strong></p>
<ol>
<li>找出基音</li>
</ol>
<p><img src="https://tva4.sinaimg.cn/large/0083jUChgy1gn2sncftjwj30dz07n76q.jpg" alt="avatar"></p>
<p>上图中红圈中圈出来的是基音</p>
<h2 id="和声"><a href="#和声" class="headerlink" title="和声"></a>和声</h2><ol>
<li>改变和弦或者基音以确保基音是一个可接受和弦音</li>
<li>可接受和弦音加强了和声的质量，提升了歌曲的一致性</li>
<li>和弦音按照其在和弦中的功能可以被分成“弱和声效果音（以下简称弱效音）”，“强和声效果音（以下简称强效音）”，“爵士效果音（以下简称爵味音）”和“不和谐音”。<ul>
<li>根音和纯五度是弱效音</li>
<li>三音，七音和增减无毒音是强效音. </li>
</ul>
</li>
</ol>
<p>下表以C的所有和弦为例，列出了十二音体系中的所有音对于和弦的和声特性：</p>
<p><img src="https://tvax2.sinaimg.cn/large/0083jUChgy1gn2sp9vlm6j30jt0iwdj1.jpg" alt=""></p>
<p>下表是当基音为C时，所有根音的所有和弦对于它的和声效果。<br><img src="https://tva4.sinaimg.cn/large/0083jUChgy1gn2spuao5ej30lz08wt9h.jpg" alt=""></p>
<p><a href="http://www.thejazzpianosite.com/jazz-piano-lessons/jazz-reharmonization/how-to-reharmonize-a-song/（图源）">http://www.thejazzpianosite.com/jazz-piano-lessons/jazz-reharmonization/how-to-reharmonize-a-song/（图源）</a></p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ol>
<li>考虑结构的时候可以忽略和弦的种类</li>
<li>使一个和弦/低音通过结构化的方式向下一个移动，具体如下：<ul>
<li>固定的音程间隔</li>
<li>沿着特定调性</li>
<li>沿着旋律线条</li>
</ul>
</li>
</ol>
<p><strong>固定间隔的种类</strong></p>
<p>音程    和弦进行举例<br>半音阶(Chromatic)    Eb7 - D7 - Db7 - CMaj7<br>全音阶    F#7 - E7 - Dm7 - CMaj7<br>小三度    Am7 - F#7 - Eb7 - CMaj7<br>大三度(Coltrane)    CMaj7 - AMaj7 - EMaj7 - CMaj7<br>纯四度（逆时针五度圈）    EbMaj7 - BbMaj7 - FMaj7 - CMaj7<br>三全音    F#7 - C7 - F#7 - C7<br>纯五度（顺时针五度圈）    A7 - Dm7 - G7 - CMaj7<br>so on…(上行下行皆可)    </p>
<p><strong>基于特定调式</strong></p>
<p>音程    和弦进行<br>固定音程    F7 - E7 - D7 - CMaj7<br>B7 - G7 - E7 - C7<br>五度圈    F7 - B7 - E7 - A7 - D7 - G7 - C7</p>
<h2 id="低音线条"><a href="#低音线条" class="headerlink" title="低音线条"></a>低音线条</h2><ul>
<li>可以通过转位和弦创造平滑的低音线条，使得低音不出现跳进</li>
<li>低音线条同样遵循结构的规则 - 固定的音程间隔，沿着某种调式，沿着旋律线条</li>
<li>低音线条和和弦的根音可以根据不同的方式进行，只要他们都遵循特定的结构且合理即可</li>
</ul>
<p><img src="https://tva4.sinaimg.cn/large/0083jUChgy1gn2sr2y1zjj30eb08241t.jpg" alt=""></p>
<h2 id="其他规则-注意事项"><a href="#其他规则-注意事项" class="headerlink" title="其他规则/注意事项"></a>其他规则/注意事项</h2><ul>
<li>通过选择和弦来增加或者减少紧张感<ul>
<li>增加紧张感——高阶延申音和变化音</li>
<li>减少紧张感——3音、7音和低阶延申音（如属9音）</li>
</ul>
</li>
<li>在旋律音时值长且重复多次时，可以改变和弦</li>
<li>如果和声进行有很强的结构性的时候，可以选择旋律音是弱效音的和弦</li>
<li>如果有旋律音是强效音的时候，那么结构这方面可以稍微弱化一点</li>
<li>如果旋律音是一串连续音符，找不出明显的基音，结构这时候比和声重要</li>
</ul>
]]></content>
      <categories>
        <category>和声学学习</category>
      </categories>
      <tags>
        <tag>和声学</tag>
        <tag>爵士和弦</tag>
        <tag>乐理</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1-回文数</title>
    <url>/2021/01/27/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><p>&emsp;&emsp;1. 题目描述：判断一个整数是否是<strong>回文数</strong>。<span id="more"></span>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。  </p>
<p>&emsp;&emsp;2. 题目分析：本题关键在于编写求回文数函数，此题难度不大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//计算回文数函数</span></span><br><span class="line">        <span class="keyword">long</span> ans =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!= <span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans*<span class="number">10</span>;</span><br><span class="line">            ans = ans+x%<span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">reverse</span>(x)==x)   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>歌曲配爵士和弦学习笔记</title>
    <url>/2021/01/28/%E6%AD%8C%E6%9B%B2%E9%85%8D%E7%88%B5%E5%A3%AB%E5%92%8C%E5%BC%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="如何让一首歌改成爵士风格（一）"><a href="#如何让一首歌改成爵士风格（一）" class="headerlink" title="如何让一首歌改成爵士风格（一）"></a>如何让一首歌改成爵士风格（一）</h1><p>——油管学习笔记，由于年代久远，原视频链接找不到了<br><span id="more"></span></p>
<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol>
<li>延申和弦</li>
<li>更改和弦音</li>
<li>插入经过和弦</li>
<li>选择合适的和声声效</li>
<li>替代和弦（重编和弦）<ol>
<li>基础的替代</li>
<li>普遍规则</li>
</ol>
</li>
<li>加入旋律装饰——填充音，和声，经过音，颤音，即兴等等</li>
</ol>
<p><img src="https://tvax1.sinaimg.cn/large/0083jUChgy1gn2s55pze5j30fh08n0vx.jpg" alt="avatar"></p>
<p>上图以Beatles的经典歌曲Let it Be 为例，列出了它的原始和弦和主旋律音</p>
<h2 id="找出歌曲每小节的主旋律音的方法（后简称为基音）"><a href="#找出歌曲每小节的主旋律音的方法（后简称为基音）" class="headerlink" title="找出歌曲每小节的主旋律音的方法（后简称为基音）"></a>找出歌曲每小节的主旋律音的方法（后简称为基音）</h2><ul>
<li>每小节第一个音</li>
<li>重拍上出现的音</li>
<li>时值长的音</li>
<li>重复的音</li>
</ul>
<p><img src="https://tva3.sinaimg.cn/large/0083jUChgy1gn2s62s2jlj30ff08hgox.jpg" alt="avatar"></p>
<p>将所有原本的和弦升级成为七和弦</p>
<p><img src="https://tva3.sinaimg.cn/large/0083jUChgy1gn2s7z2ir9j30fe08nq6q.jpg" alt="avatar"></p>
<p>将七和弦继续升级，使其和声效果更加丰富<br><img src="https://tvax4.sinaimg.cn/large/0083jUChgy1gn2s9im7j9j30f408f410.jpg" alt="avatar"></p>
<p>变化音规则：</p>
<ul>
<li>可以变化该和弦中的任何音除了基音</li>
</ul>
<p><img src="https://tvax1.sinaimg.cn/large/0083jUChgy1gn2saczhu3j30ev08eadw.jpg" alt="avatar"><br><img src="https://tvax3.sinaimg.cn/large/0083jUChgy1gn2sawhmpyj30ey08ftbu.jpg" alt="avatar"></p>
<p>以上是基于原有和弦进行的和弦编配，整体框架还是在原有和弦的基础上。<br>——————————————————————分割线——————————————————————————<br>以下是重配和弦，相当于完全不看原有和弦，对旋律线重新配爵士和声。</p>
<h2 id="重配和弦法则——为什么只有特定的和弦可以作为替代和弦"><a href="#重配和弦法则——为什么只有特定的和弦可以作为替代和弦" class="headerlink" title="重配和弦法则——为什么只有特定的和弦可以作为替代和弦"></a>重配和弦法则——为什么只有特定的和弦可以作为替代和弦</h2><ul>
<li>重配和弦完全取决于每小节的旋律基音（以下简称基音）</li>
<li>普遍法则：可以改变一个和弦中任何音，除了基音</li>
<li>可以改变3rd、7rd和根音，进而改变了和弦的质量和调性</li>
<li>必须理解‘可接受的和声’以及‘可用紧张感’</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0083jUChgy1gn2sbeyizyj30f808eq89.jpg" alt="avatar"></p>
<p>以上以C的几种和弦为例，列举出了每个和弦音的和声作用（包括弱和音，强和音，爵士合音，以及不和谐音）</p>
<p><img src="https://tvax2.sinaimg.cn/large/0083jUChgy1gn2scebl9yj30eq08bmzz.jpg" alt="avatar"></p>
<p>以上是当基音为G时，可以选择的重配和弦的种类。可以看见，基本上12音体系中的所有音都可以作为重配和弦的根音。而该和弦是否合适主要取决于上表，可以根据它设计和弦重配算法算法。</p>
<h2 id="重配和弦步骤"><a href="#重配和弦步骤" class="headerlink" title="重配和弦步骤"></a>重配和弦步骤</h2><ol>
<li>选择任何一个对于基音的可用和弦</li>
<li>结构化地进行到相邻的和弦<ol>
<li>半音进行，例如E7进行到EbMaj7</li>
<li>全音进行，如从Em7到Dm7</li>
<li>五度圈进行，如从B7到Em7</li>
</ol>
</li>
<li>选择紧张度交替进行的和声进行<ol>
<li>增加紧张度，高阶延申音和变化音（如b13）</li>
<li>降低紧张度，3rd，7th音以及低阶延申音和变化音（如9th）</li>
</ol>
</li>
</ol>
<p><img src="https://tva3.sinaimg.cn/large/0083jUChgy1gn2sd0ii2ij30ew088dju.jpg" alt="avatar"></p>
<p>Let it Be重配和声后的其中一个版本<br><img src="https://tva2.sinaimg.cn/large/0083jUChgy1gn2sdlkp4bj30et08btbj.jpg" alt="avatar"></p>
<p>复杂和声的和弦音功能表</p>
]]></content>
      <categories>
        <category>和声学学习</category>
      </categories>
      <tags>
        <tag>和声学</tag>
        <tag>爵士和弦</tag>
        <tag>乐理</tag>
      </tags>
  </entry>
</search>
