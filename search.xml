<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo的几种报错</title>
    <url>/2021/04/28/hexo%E4%B8%8A%E4%BC%A0%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h1 id="Hexo的几种报错"><a href="#Hexo的几种报错" class="headerlink" title="Hexo的几种报错"></a>Hexo的几种报错</h1><ol>
<li><p>npm命令找不到<br>环境变量的配置有误，检查环境变量中是否有Node安装路径</p>
</li>
<li><p>hexo中deploy操作无法上传至github<br>挂梯子再重新登录一遍github。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>DP动态规划算法（未完）</title>
    <url>/2021/01/28/DP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h2 id="一、动态规划简介"><a href="#一、动态规划简介" class="headerlink" title="一、动态规划简介"></a>一、动态规划简介</h2><p>&emsp;&emsp;与分治法类似，即将待求解问题分解为若干子问题，先求解子问题，再由子问题的解得到原问题的解。<span id="more"></span>与分治法不同，它可以通过保存已解决子问题的答案来避免重复计算。加上记忆化之后相当于牺牲了一定的空间复杂度来换取时间复杂度。</p>
<script type="math/tex; mode=display">动态规划\left\{
\begin{matrix}
 递推求解 \\
 最大连续子序列和\\
 最大递增子序列和\\
 最大公共子序列\\
 背包问题 
\end{matrix}
\right.</script><p>动态规划两种方法：</p>
<p>1.递归策略+记忆法 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;  2.递推求解<br>（注：代码中最好不要出现递归，递归可能导致代码执行偏慢）</p>
<h2 id="一、最大连续子序列和"><a href="#一、最大连续子序列和" class="headerlink" title="一、最大连续子序列和"></a>一、最大连续子序列和</h2><p><strong>eg1.</strong> 给出一个整数序列S，其中有N个数，定义其中一个非空连续子序列T中所有数的和为T的“序列和”。 对于S的所有非空连续子序列T，求最大的序列和。 变量条件：N为正整数，N≤1000000，结果序列和在范围（-$2^ (63)$,$2^ (63)$-1）以内。</p>
<p>&emsp;&emsp;题目分析：本题如果采用最暴力的解法，即不固定子字符串首位，则遍历所有子序列的时间复杂度为O($n^2$)，求序列和的时间复杂度为O($n$)，总时间复杂度为O($n^3$).如果固定子序列尾部采用递归的手段，时间复杂度为O($n^2$)。<br>如果在递归的基础上加上记忆法，即动态规划的方法，时间复杂度可以降到O($n$)。同理，可以将此递归+记忆法的方法改变成递推求解。题目还有一个易错点即变量类型，可以由序列和的范围知最好采用long long型。<br>&emsp;&emsp;递推求解的代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MINN = <span class="number">-1e6</span><span class="number">-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> arr[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[MAXN];<span class="comment">//记录以输入每个元素结尾的最大字符和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> maximum = MINN;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span>)	dp[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span>    dp[i]  = <span class="built_in">max</span>(arr[i],dp[i<span class="number">-1</span>]+arr[i]);</span><br><span class="line">		maximum =<span class="built_in">max</span>(maximum,dp[i]); <span class="comment">//对递归求解的优化部分</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maximum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;arr[i]);</span><br><span class="line">		&#125;<span class="comment">//输入参数模块，基操</span></span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="built_in">func</span>(n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一、最大连续子序列和-1"><a href="#一、最大连续子序列和-1" class="headerlink" title="一、最大连续子序列和"></a>一、最大连续子序列和</h2>]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1-回文数</title>
    <url>/2021/01/27/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><p>&emsp;&emsp;1. 题目描述：判断一个整数是否是<strong>回文数</strong>。<span id="more"></span>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。  </p>
<p>&emsp;&emsp;2. 题目分析：本题关键在于编写求回文数函数，此题难度不大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//计算回文数函数</span></span><br><span class="line">        <span class="keyword">long</span> ans =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!= <span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans*<span class="number">10</span>;</span><br><span class="line">            ans = ans+x%<span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">reverse</span>(x)==x)   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记——反转链表</title>
    <url>/2021/01/31/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>&emsp;&emsp;定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<br><span id="more"></span></p>
<p>示例:</p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre><p>0 &lt;= 节点个数 &lt;= 5000</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;此题很明显时间复杂度不会超过O(n),如果新建一个链表进行头插，那么空间复杂度为O(n)。现思考有没有空间复杂度为O(1)的解法，即在原本的链表基础上进行改动。</p>
<p>&emsp;&emsp;设定双指针pre和cur用于交换。而next作为中间指针保存cur.next的信息。算法图示如下：<br><img src="https://tva1.sinaimg.cn/large/0083jUChgy1gn6xc46di9j30qt0j60uz.jpg" alt="avatar"></p>
<p>具体代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        ListNode *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此题为大厂常考题目，建议熟记于心。</p>
]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-2-最长回文子串</title>
    <url>/2021/01/28/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<h1 id="最长回文子串-TENET"><a href="#最长回文子串-TENET" class="headerlink" title="最长回文子串(TENET)"></a>最长回文子串(TENET)</h1><p>&emsp;&emsp;题目描述：给你一个字符串 s，找到 s 中最长的回文子串。<span id="more"></span>1 &lt;= s.length &lt;= 1000且 s 仅由数字和英文字母（大写和/或小写）组成。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;看到题目的第一眼不难想到暴力解法，如果字符串长度为t的话，那么从头到尾遍历所有的字符串时间复杂度为O($t^2$),而此情况下判断字符串是否回文的最小时间复杂度为O($t$),所以总时间复杂度为O($t^3$),由于y最大为1000，因此此方法超时。<br>&emsp;&emsp;之后想到一种去除冗余遍历的方式，如果以字符串元素s[i]为中点，然后以中点向外发散式的遍历字符串。这样遍历有一种好处，那就是如果扩散到外围某个元素发现此时不回文了，那么此时可以中止向外扩散。<br>&emsp;&emsp;但是有一个问题，中心扩散有两种方式。若用mid指代中心元素位置，一种有奇数个元素，即mid在字符串正中间。第二种是有偶数个元素，那么mid处于中心偏右或者中心偏左的位置。因此要分情况讨论，下面我们默认mid只能处于中心偏右。<br>&emsp;&emsp;采用了这种算法后，对于是否回文的判断也简化了，对于同一个mid，是否回文只需判断最外圈层的元素是否对称，即时间复杂度为O(1),总时间复杂度降为O($n^2$)了。<br>具体代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><span class="comment">//时间复杂度O(n^2)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Ishuiwen</span><span class="params">(string x)</span></span>&#123;<span class="comment">//此函数用于判断字符串是否回文</span></span><br><span class="line">        <span class="keyword">if</span>(x[<span class="number">0</span>]==x[x.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用中心扩散法来减少计算量</span></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;<span class="comment">//中心元素</span></span><br><span class="line">        <span class="keyword">int</span> front;<span class="comment">//扩散字符串的头指针</span></span><br><span class="line">        <span class="keyword">int</span> halflength;<span class="comment">//由于是中心扩散，所以定义一个半长</span></span><br><span class="line">        <span class="keyword">int</span> length;<span class="comment">//当前遍历字符串总长度</span></span><br><span class="line">        string ans=s.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//答案字符串</span></span><br><span class="line">        <span class="keyword">int</span> anslength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(mid = <span class="number">0</span>;mid&lt;s.<span class="built_in">size</span>();mid++)&#123;</span><br><span class="line">            halflength = <span class="number">0</span>;</span><br><span class="line">            front = mid;</span><br><span class="line">            length = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">Ishuiwen</span>(s.<span class="built_in">substr</span>(front,length)))&#123;<span class="comment">//第一种情况，以mid为中心</span></span><br><span class="line">                front = mid-halflength;</span><br><span class="line">                length = <span class="number">2</span>*halflength+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[front]==s[front+length<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(length&gt;anslength)&#123;</span><br><span class="line">                        ans = s.<span class="built_in">substr</span>(front, length);</span><br><span class="line">                        anslength = length;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">break</span>;</span><br><span class="line">                halflength++;</span><br><span class="line">            &#125;</span><br><span class="line">            halflength = <span class="number">0</span>;</span><br><span class="line">            front = mid;</span><br><span class="line">            length = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">Ishuiwen</span>(s.<span class="built_in">substr</span>(front,length)))&#123;<span class="comment">//第二种情况，mid为中心右侧</span></span><br><span class="line">                front = mid-halflength<span class="number">-1</span>;</span><br><span class="line">                length = <span class="number">2</span>*(halflength+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(s[front]==s[front+length<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(length&gt;anslength)&#123;</span><br><span class="line">                        ans = s.<span class="built_in">substr</span>(front, length);</span><br><span class="line">                        anslength = length;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">break</span>;</span><br><span class="line">                halflength++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然而此发超时，因此还需进一步去除代码冗余，后经分析得知，判断时候冗余的函数 bool Ishuiwen(string x) 可以直接用一个判断语句代替。  </p>
<pre><code>if(s[front]==s[front+length-1])
</code></pre><p>&emsp;&emsp;再次运行代码没有超时。此题还可以用动态规划的方法，目前未掌握。</p>
]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>人声混声踩坑指南（刚开坑）</title>
    <url>/2021/04/20/%E4%BA%BA%E5%A3%B0%E6%B7%B7%E5%A3%B0%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="人声混声踩坑指南"><a href="#人声混声踩坑指南" class="headerlink" title="人声混声踩坑指南"></a>人声混声踩坑指南</h1><h2 id="录制基础问题集合"><a href="#录制基础问题集合" class="headerlink" title="录制基础问题集合"></a>录制基础问题集合</h2><ol>
<li><p>不能勾选音频栏的监听，因为我的麦克风自带声卡，如果再用电脑声卡将难以一起带动。</p>
<span id="more"></span>
</li>
<li><p>blueyeti等麦克风侦听没有声音的解决方法：<br>1、打开声音控制面板<br><img src="https://tvax1.sinaimg.cn/large/005Au8gjgy1gqa8vkkzdbj30ps0tc76g.jpg" alt=""><br>2、将级别下面麦克风的小喇叭打开。<br><img src="https://tvax1.sinaimg.cn/large/005Au8gjgy1gqa8wqamv4j30pj0szmyy.jpg" alt=""><br>3、同时确认一下应用使用麦克风的权限是否打开。</p>
</li>
</ol>
<h2 id="混音处理办法"><a href="#混音处理办法" class="headerlink" title="混音处理办法"></a>混音处理办法</h2><p>wavestune，一个非常好的校准音高的插件，但是建议自己手动修音。</p>
<p>消除气息可以直接用包络，降噪的方法目前还是不太会。</p>
<p>压缩效果器，compressor。<br><img src="https://tva3.sinaimg.cn/mw690/005Au8gjgy1gpjdicyhhwj30l70oxgr9.jpg" alt=""></p>
<p>对齐不要选</p>
<p>粘合功能仅仅只是机械的将两段音频连接，没有灵魂</p>
<p><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjgy1gpjiyk8dlfj314y0uewm0.jpg" alt=""></p>
<p><img src="https://tva4.sinaimg.cn/mw690/005Au8gjgy1gpjj5bb5ygj314u0ug10d.jpg" alt=""></p>
<p><img src="https://tva4.sinaimg.cn/mw690/005Au8gjgy1gpjkq2x8hij303x05ua9w.jpg" alt=""></p>
<p>下一首翻唱曲目选择黄龄的醉。</p>
<h3 id="去除齿音"><a href="#去除齿音" class="headerlink" title="去除齿音"></a>去除齿音</h3><p>强烈的唇齿音在大多数情况下，去除比较好一点。<br>用下述waves插件进去齿音去除。<br><img src="https://tva4.sinaimg.cn/mw690/005Au8gjgy1gqekksjdauj30ui10gti3.jpg" alt=""></p>
<p>thresh代表门限，如果调的越低代表可以过滤的齿音越多。<br>reduct是衰减的意思，代表过滤的程度<br>左侧LO，HI代表去除齿音的频率区间。<br>刺耳的片段也可以单挂它修一下。</p>
<h2 id="网易云传送流程"><a href="#网易云传送流程" class="headerlink" title="网易云传送流程"></a>网易云传送流程</h2><p>无需管音量，网易云会自动转码处理。</p>
]]></content>
      <categories>
        <category>人声</category>
      </categories>
      <tags>
        <tag>vocal</tag>
        <tag>mix</tag>
        <tag>daw</tag>
      </tags>
  </entry>
  <entry>
    <title>歌曲配爵士和弦学习笔记</title>
    <url>/2021/01/28/%E6%AD%8C%E6%9B%B2%E9%85%8D%E7%88%B5%E5%A3%AB%E5%92%8C%E5%BC%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="如何让一首歌改成爵士风格（一）"><a href="#如何让一首歌改成爵士风格（一）" class="headerlink" title="如何让一首歌改成爵士风格（一）"></a>如何让一首歌改成爵士风格（一）</h1><p>——油管学习笔记，由于年代久远，原视频链接找不到了<br><span id="more"></span></p>
<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol>
<li>延申和弦</li>
<li>更改和弦音</li>
<li>插入经过和弦</li>
<li>选择合适的和声声效</li>
<li>替代和弦（重编和弦）<ol>
<li>基础的替代</li>
<li>普遍规则</li>
</ol>
</li>
<li>加入旋律装饰——填充音，和声，经过音，颤音，即兴等等</li>
</ol>
<p><img src="https://tvax1.sinaimg.cn/large/0083jUChgy1gn2s55pze5j30fh08n0vx.jpg" alt="avatar"></p>
<p>上图以Beatles的经典歌曲Let it Be 为例，列出了它的原始和弦和主旋律音</p>
<h2 id="找出歌曲每小节的主旋律音的方法（后简称为基音）"><a href="#找出歌曲每小节的主旋律音的方法（后简称为基音）" class="headerlink" title="找出歌曲每小节的主旋律音的方法（后简称为基音）"></a>找出歌曲每小节的主旋律音的方法（后简称为基音）</h2><ul>
<li>每小节第一个音</li>
<li>重拍上出现的音</li>
<li>时值长的音</li>
<li>重复的音</li>
</ul>
<p><img src="https://tva3.sinaimg.cn/large/0083jUChgy1gn2s62s2jlj30ff08hgox.jpg" alt="avatar"></p>
<p>将所有原本的和弦升级成为七和弦</p>
<p><img src="https://tva3.sinaimg.cn/large/0083jUChgy1gn2s7z2ir9j30fe08nq6q.jpg" alt="avatar"></p>
<p>将七和弦继续升级，使其和声效果更加丰富<br><img src="https://tvax4.sinaimg.cn/large/0083jUChgy1gn2s9im7j9j30f408f410.jpg" alt="avatar"></p>
<p>变化音规则：</p>
<ul>
<li>可以变化该和弦中的任何音除了基音</li>
</ul>
<p><img src="https://tvax1.sinaimg.cn/large/0083jUChgy1gn2saczhu3j30ev08eadw.jpg" alt="avatar"><br><img src="https://tvax3.sinaimg.cn/large/0083jUChgy1gn2sawhmpyj30ey08ftbu.jpg" alt="avatar"></p>
<p>以上是基于原有和弦进行的和弦编配，整体框架还是在原有和弦的基础上。<br>——————————————————————分割线——————————————————————————<br>以下是重配和弦，相当于完全不看原有和弦，对旋律线重新配爵士和声。</p>
<h2 id="重配和弦法则——为什么只有特定的和弦可以作为替代和弦"><a href="#重配和弦法则——为什么只有特定的和弦可以作为替代和弦" class="headerlink" title="重配和弦法则——为什么只有特定的和弦可以作为替代和弦"></a>重配和弦法则——为什么只有特定的和弦可以作为替代和弦</h2><ul>
<li>重配和弦完全取决于每小节的旋律基音（以下简称基音）</li>
<li>普遍法则：可以改变一个和弦中任何音，除了基音</li>
<li>可以改变3rd、7rd和根音，进而改变了和弦的质量和调性</li>
<li>必须理解‘可接受的和声’以及‘可用紧张感’</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0083jUChgy1gn2sbeyizyj30f808eq89.jpg" alt="avatar"></p>
<p>以上以C的几种和弦为例，列举出了每个和弦音的和声作用（包括弱和音，强和音，爵士合音，以及不和谐音）</p>
<p><img src="https://tvax2.sinaimg.cn/large/0083jUChgy1gn2scebl9yj30eq08bmzz.jpg" alt="avatar"></p>
<p>以上是当基音为G时，可以选择的重配和弦的种类。可以看见，基本上12音体系中的所有音都可以作为重配和弦的根音。而该和弦是否合适主要取决于上表，可以根据它设计和弦重配算法算法。</p>
<h2 id="重配和弦步骤"><a href="#重配和弦步骤" class="headerlink" title="重配和弦步骤"></a>重配和弦步骤</h2><ol>
<li>选择任何一个对于基音的可用和弦</li>
<li>结构化地进行到相邻的和弦<ol>
<li>半音进行，例如E7进行到EbMaj7</li>
<li>全音进行，如从Em7到Dm7</li>
<li>五度圈进行，如从B7到Em7</li>
</ol>
</li>
<li>选择紧张度交替进行的和声进行<ol>
<li>增加紧张度，高阶延申音和变化音（如b13）</li>
<li>降低紧张度，3rd，7th音以及低阶延申音和变化音（如9th）</li>
</ol>
</li>
</ol>
<p><img src="https://tva3.sinaimg.cn/large/0083jUChgy1gn2sd0ii2ij30ew088dju.jpg" alt="avatar"></p>
<p>Let it Be重配和声后的其中一个版本<br><img src="https://tva2.sinaimg.cn/large/0083jUChgy1gn2sdlkp4bj30et08btbj.jpg" alt="avatar"></p>
<p>复杂和声的和弦音功能表</p>
]]></content>
      <categories>
        <category>和声学学习</category>
      </categories>
      <tags>
        <tag>和声学</tag>
        <tag>爵士和弦</tag>
        <tag>乐理</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记——寻找两个正序数的中位数</title>
    <url>/2021/02/02/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>&emsp;&emsp;给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。<br><span id="more"></span></p>
<p>示例 1：</p>
<pre><code>输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
</code></pre><p>示例 2：</p>
<pre><code>输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
</code></pre><p>示例 3：</p>
<pre><code>输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
</code></pre><p>示例 4：</p>
<pre><code>输入：nums1 = [], nums2 = [1]
输出：1.00000
</code></pre><p>示例 5：</p>
<pre><code>输入：nums1 = [2], nums2 = []
输出：2.00000
</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a></p>
<p>提示：</p>
<pre><code>nums1.length == m
nums2.length == n
0 &lt;= m &lt;= 1000
0 &lt;= n &lt;= 1000
1 &lt;= m + n &lt;= 2000
-106 &lt;= nums1[i], nums2[i] &lt;= 106
</code></pre><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;此题很明显时间复杂度不会超过O(n),如果新建一个链表进行头插，那么空间复杂度为O(n)。现思考有没有空间复杂度为O(1)的解法，即在原本的链表基础上进行改动。</p>
<p>&emsp;&emsp;设定双指针pre和cur用于交换。而next作为中间指针保存cur.next的信息。算法图示如下：<br><img src="" alt="avatar"></p>
<p>具体代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        ListNode *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此题为大厂常考题目，建议熟记于心。</p>
]]></content>
      <categories>
        <category>Leetcode刷题笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>考虑突触串扰的双曲型忆阻Hopfield神经网络的动力学行为(文献阅读)</title>
    <url>/2021/05/05/%E8%80%83%E8%99%91%E7%AA%81%E8%A7%A6%E4%B8%B2%E6%89%B0%E7%9A%84%E5%8F%8C%E6%9B%B2%E5%9E%8B%E5%BF%86%E9%98%BBHopfield%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<h1 id="考虑突触串扰的双曲型忆阻Hopfield神经网络的动力学行为"><a href="#考虑突触串扰的双曲型忆阻Hopfield神经网络的动力学行为" class="headerlink" title="考虑突触串扰的双曲型忆阻Hopfield神经网络的动力学行为"></a>考虑突触串扰的双曲型忆阻Hopfield神经网络的动力学行为</h1><p>Dynamic behaviors of hyperbolic-type memristor-based Hopfield neural network considering synaptic crosstalk<br><span id="more"></span>Cite as: Chaos 30, 033108 (2020); <a href="https://doi.org/10.1063/5.0002076">https://doi.org/10.1063/5.0002076</a><br><a href="https://maiimg.com/pdf/?e=agS3v4tv8tYQ2m">https://maiimg.com/pdf/?e=agS3v4tv8tYQ2m</a> (该链接仅供学习用途)</p>
<h2 id="一、摘要"><a href="#一、摘要" class="headerlink" title="一、摘要"></a>一、摘要</h2><p>突触之间发生的串扰现象可以影响信号传输，在某些情况下，还会影响大脑功能。因此，研究受突触串扰影响的神经网络的动态行为具有重要意义。为了实现这一目标，本文设计了一种新的电路来模拟耦合双曲忆阻器，然后利用该电路来模拟Hopfield神经网络(HNN)的突触串扰。然后，在不同的串扰强度下，观察到HNN的多重稳定性、不对称吸引子和反单调性。利用分岔图、动态图和李雅普诺夫指数谱分析了HNN的动力学行为，并考虑了不同级别的串扰强度。仿真结果还表明，不同的串扰强度会导致HNN系统的广泛非线性行为。</p>
<h2 id="二、两个耦合双曲记忆仿真器"><a href="#二、两个耦合双曲记忆仿真器" class="headerlink" title="二、两个耦合双曲记忆仿真器"></a>二、两个耦合双曲记忆仿真器</h2><p>神经元激活函数一般采用双曲正切函数（tanh）表示。双曲型磁流变仿真器的本构关系可以用如下公式表示：<br><img src="https://tva1.sinaimg.cn/mw690/005Au8gjly1gq7avi6c0rj30rj05g0sz.jpg" alt=""></p>
<p>双曲正切函数单元的输出可以通过如下公式表示：<br><img src="https://tvax3.sinaimg.cn/mw690/005Au8gjly1gq7b7jvbztj30hd028dfp.jpg" alt=""></p>
<p>通过两个MR仿真器之间的耦合连接来仿真两个突触的串扰，对于两个突触权值，通过将参数缩放为无因次形式，我们得到<br><img src="https://tvax1.sinaimg.cn/mw690/005Au8gjly1gq7b8o2dqdj30fg03ijrh.jpg" alt=""></p>
<h2 id="三、耦合双曲型忆阻HNN神经元"><a href="#三、耦合双曲型忆阻HNN神经元" class="headerlink" title="三、耦合双曲型忆阻HNN神经元"></a>三、耦合双曲型忆阻HNN神经元</h2><p>第i个节点的状态方程：<br><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gq7bbpgpdnj30gw02maa1.jpg" alt=""></p>
<p>本研究采用了一个包含三个神经元的HNN系统，在神经元1和神经元3之间建立了两个耦合忆阻来模拟串扰。这种带有串扰的记忆HNN可以用无量纲形式导出<br><img src="https://tva1.sinaimg.cn/mw690/005Au8gjly1gq7be4qqyyj30jo071aap.jpg" alt=""></p>
<p>注意$W_1= a_1−b_1tanh(u) + c_1tanh(w)$是来自神经元1影响神经元3的突触权值，$W_2= a_2−b_2tanh(w) + c_2tanh(u)$是来自神经元3影响神经元1的突触权值。$k_1$和$k_2$为耦合强度，$c_1$和$c_2$分别为w1和W2的串扰强度。</p>
<p>引入李亚普诺夫函数，有<br><img src="https://tva3.sinaimg.cn/mw690/005Au8gjly1gq7br1o25sj30iz02gdft.jpg" alt=""></p>
<p>求导，将(7)带入:<br><img src="https://tvax1.sinaimg.cn/mw690/005Au8gjly1gq7bwmwgx8j30ll079mxp.jpg" alt=""></p>
<p>将后面一串赋值<br><img src="https://tvax1.sinaimg.cn/mw690/005Au8gjly1gq7bxmyvcdj30le04dq3b.jpg" alt=""></p>
<p>公式（11）可以被重写成：<br><img src="https://tva1.sinaimg.cn/mw690/005Au8gjly1gq7bygcjw9j30j001ljrc.jpg" alt=""></p>
<p>由$W_1$和$W_2$定义可知：<br><img src="https://tva1.sinaimg.cn/mw690/005Au8gjly1gq7bywhibjj30hg04amx6.jpg" alt=""></p>
<p>写成以下形式：<br><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gq7bzz64pgj30ke03zjrk.jpg" alt=""></p>
<p>公式12可以被化简成如下形式：<br><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gq7c225afbj30l00e0gmu.jpg" alt=""></p>
<p>此条件恒成立（存疑）：<br><img src="https://tva4.sinaimg.cn/mw690/005Au8gjly1gq7cejaxa5j30j405o3yu.jpg" alt=""></p>
<p>然后就可以得出<br><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gq7cfl2tb3j30i801yq2w.jpg" alt=""></p>
<h2 id="四、平衡点和稳定性分析"><a href="#四、平衡点和稳定性分析" class="headerlink" title="四、平衡点和稳定性分析"></a>四、平衡点和稳定性分析</h2><p>设定如下权值矩阵：<br><img src="https://tvax1.sinaimg.cn/mw690/005Au8gjly1gq7crzbnlvj30gc03mq2z.jpg" alt=""></p>
<h3 id="A-对称性"><a href="#A-对称性" class="headerlink" title="A.对称性"></a>A.对称性</h3><p>改变初始条件和变量(x, y, z, u, w, b1, b2, c1, c2)。系统在(x, y, z, u, w, b1, b2, c1, c2)到(−x，−y，−z，−u，−w，−b1，−b2，−c1，−c2)的变换下是不变的，因此，具有串扰的HNN是对称的。<br><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gq7cvhekujj30kr0apgnf.jpg" alt=""><br>图5(a)和图5(b)所示的吸引子的系统参数分别为:$b1= 0.02, b2= 0.03, c1= 0.2, c2= 0.2$和$b1=−0.02,b2=−0.03,c1=−0.2,c2=−0.2$。图5(a)和图5(b)的初始条件分别为$(0,0.1,0,0,0,0)$和$(0，−0.1,0,0,0)$。当参数和初始条件都相反时，可以发现混沌相轨图具有反中心对称性(图中关于z=x对称)。</p>
<h3 id="B-平衡点分析"><a href="#B-平衡点分析" class="headerlink" title="B.平衡点分析"></a>B.平衡点分析</h3><p>将状态方程左侧设为0，可以从数值上确定HNN的平衡点。可以从数值上确定具有串扰的HNN的平衡点，即1个零平衡点$P0(0,0,0,0,0)$和2个非零平衡点$P_1(η_1，η_2，η_3，η_4，η_5)$和$P_2(η_1，η_2，η_3，η_4，η_5)$。对于未定义的常数变量，$η_1 = x_1，η_3 = z_1， \mu_1 = x_2， \mu_3 = z_2$的非零平衡点通过求解以下两个方程集计算:<br><img src="https://tvax3.sinaimg.cn/mw690/005Au8gjly1gq7miyufmbj30iv0c2aau.jpg" alt=""></p>
<p>将方程组Eq.(22)代入Eq.(7)可以得到如下两条曲线（仅需简单消y即可）：<br><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gq7mrxutonj30mt08z0tm.jpg" alt=""></p>
<p>式中(x1,z1)、(x2,z2)为上述两条函数曲线的交点，(x1,z1)、(x2,z2)可以用图解分析法确定。以$k_1= k_2= 1, a_1= 1, a_2= 7, b_1= 0.02, b_2= 0.03, c_1= c_2= 0.2$为例<br><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gq7n2pex2ij30lw0n3go3.jpg" alt=""></p>
<p>显然，P1和P2这两个非零的平衡点是不对称的。由图可知串扰强度c1对函数$h_2(x,z)$的形状有很大影响。因此，可以利用串扰强度系数来改变非对称平衡点的位置。<br>平衡点处的雅可比矩阵如下：<br><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gq7njnep0kj30la065t94.jpg" alt=""></p>
<p>其中：<br><img src="https://tvax2.sinaimg.cn/mw690/005Au8gjly1gq7nk2n55wj30fs02pq30.jpg" alt=""><br><img src="https://tva3.sinaimg.cn/mw690/005Au8gjly1gq7npb9gp5j30f905tq3d.jpg" alt=""></p>
<p>在P0平衡点，得到特征多项式：<br><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gq7nq7irpqj30la047jrn.jpg" alt=""></p>
<p>特征多项式方程中的系数只与$a_1,k_1$和$a_2,k_2$有关，而与忆阻内部参数b1和b2以及串扰强度c1和c2无关。<br>k1= 1, a1= 1, a2= 7时，根据Routh准则，当0.7381 &lt; k2 &lt; 0.8206时，可以确认p0是稳定的。</p>
<p>对于两个非零平衡点p1和P2，可以令特征方程为0求解对应的特征值。当$k_1= k_2= 1,a_1= 1,a_2= 7,b_1= 0.02,b_2= 0.03$和$k_1= 0.8, k_2= 1,a_1= 1,a_2= 7,b_1= 0.02,b_2= 0.03$作为不同的串扰强度系数时，两个非零平衡点、对应的特征值和混沌吸引子类型分别如表I和表II所示。<br><img src="https://tva1.sinaimg.cn/large/005Au8gjly1gq7o1kqltjj31bn0fz79q.jpg" alt=""><br><img src="https://tva3.sinaimg.cn/large/005Au8gjly1gq7o0nhmjvj31bs0c5jvb.jpg" alt=""></p>
<h2 id="五、不对称吸引子的共存和不同串扰强度下的多稳态行为"><a href="#五、不对称吸引子的共存和不同串扰强度下的多稳态行为" class="headerlink" title="五、不对称吸引子的共存和不同串扰强度下的多稳态行为"></a>五、不对称吸引子的共存和不同串扰强度下的多稳态行为</h2><h3 id="A-c1改变时的动态特性"><a href="#A-c1改变时的动态特性" class="headerlink" title="A.c1改变时的动态特性"></a>A.c1改变时的动态特性</h3><p>当$k1= k2= 1, a1= 1, a2= 7, b1= 0.02, b2= 0.03, c2= 0.2$，初始仿真条件设为$(0,0.1,0,0,0)$时，状态变量z随第一次串扰强度参数$c1$变化的分叉图如图8(a)所示。8(b)是初始条件为(0，−0.1,0,0,0)时。可以看出两个图并不对称。<br><img src="https://tvax2.sinaimg.cn/mw690/005Au8gjly1gq7d8z5rmpj30q10ekwgy.jpg" alt=""></p>
<p>图9绘制了$x - z$平面上共存的非对称吸引子的相图，其中初始条件为$(0,0.1,0,0,0,0,0)$和$(0，−0.1,0,0,0,0)$的相图分别用红色和蓝色绘制。这些结果表明了非对称吸引子的存在和多稳定性行为。<br>(a)c1=−0.28<br>(b)c1=−0.05<br>(c)c1=−0.05<br>(d)c1= 0.2<br>(e)c1= 0.292<br>(f)c1= 0.335<br>可以发现，相图与分岔图吻合。<br><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gq7duxgumtj30me0tg78j.jpg" alt=""></p>
<p>下图是c1变化时候的lyapunov指数图。<br>(a)初始条件(0,0.1,0,0,0)<br>(b)初始条件(0，−0.1,0,0,0)<br><img src="https://tvax3.sinaimg.cn/mw690/005Au8gjly1gq7dyoj8bjj30m909sdhf.jpg" alt="fig.10"></p>
<h3 id="B-c2改变时的动态特性"><a href="#B-c2改变时的动态特性" class="headerlink" title="B.c2改变时的动态特性"></a>B.c2改变时的动态特性</h3><p>不同初始条件下的分岔图：(a)初始条件(0,0.1,0,0,0,0,0)和(b)初始条件(0，−0.1,0,0,0,0)。<br><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gq7e1zjntmj30mf09itbf.jpg" alt="fig.11"></p>
<p>不同c2值时候两种初始条件下的相图：<br>(a)c2 =−1.5<br>(b)c2 =−0.95<br>(c)c2 =−0.8<br>(d)c2 =−0.35<br>(e)c2 = 1<br>(f)c2= 2.2<br><img src="https://tva3.sinaimg.cn/mw690/005Au8gjly1gq7e2erzj2j30n50t4gp3.jpg" alt="fig.12"></p>
<p>选择c1= c2= 0.2作为典型的混沌串扰强度参数，在初始条件y(0)改变的情况下绘制的分岔图如图13所示。可以发现，混沌状态之间存在一个周期-1窗口，<br><img src="https://tva3.sinaimg.cn/mw690/005Au8gjly1gq7eaiqjudj30lt0gh7am.jpg" alt=""></p>
<p>图14绘制了典型混沌参数$c1= c2= 0.2$下初始条件$x<em>{(0)}$和$y</em>{(0)}$的动态映射。混沌状态用绿色标记，而周期状态的区域用红色标记<br><img src="https://tva4.sinaimg.cn/mw690/005Au8gjly1gq7kehy802j30kc0gxmzm.jpg" alt=""></p>
<p>图15为随串扰强度c2变化的Lyapunov指数谱，与分岔图相吻合。<br><img src="https://tvax3.sinaimg.cn/mw690/005Au8gjly1gq7khdcsp0j30ib0eqgn8.jpg" alt="fig.15"></p>
<p>在初始条件$(0,0.1,0,0,0,0)$下，分别以串扰强度参数$c_1$和$c_2$为横轴变量和纵轴变量，绘制出串扰强度参数的动态映射如图16所示。<br><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gq7kiqj9x1j30id0fzwha.jpg" alt=""></p>
<h2 id="六、抗单调性和随串扰强度变化的吸引子行为"><a href="#六、抗单调性和随串扰强度变化的吸引子行为" class="headerlink" title="六、抗单调性和随串扰强度变化的吸引子行为"></a>六、抗单调性和随串扰强度变化的吸引子行为</h2><h3 id="A-变化的串扰强度时重新合并的Feigenbaum树"><a href="#A-变化的串扰强度时重新合并的Feigenbaum树" class="headerlink" title="A.变化的串扰强度时重新合并的Feigenbaum树"></a>A.变化的串扰强度时重新合并的Feigenbaum树</h3><p>以突触权值矩阵$W_0$为例，当$k_1= k_2= 1, a_1= 1, a_2= 7, b_2= 0.03, c_2= 0.2$时，可以得到不同c1值下通过改变b1而得到的分岔图。图18通过减少c1显示了从气泡到树的演变过程。<br><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gq7kn7doelj30ly0nygpj.jpg" alt=""><br>同理，增加$c_2$<br><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gq7kt7waauj30m80onjvt.jpg" alt=""><br>可以发现，当两个串扰强度参数发生变化时，Feigenbaum树的动态行为非常丰富。图18和图19反映了类似的演化过程，从四个平行的二循环气泡分支开始，然后分叉为四个四循环气泡分支和小树。随着串扰强度参数的进一步变化，不同分支的树合并，气泡与树之间以及两个不同的树之间出现串联。</p>
<p>当改变其中一个串扰强度时，所绘制的一组分支图对于描述重新归并的Feigenbaum树与该串扰强度之间的关系具有高度代表性。<br><img src="https://tvax1.sinaimg.cn/mw690/005Au8gjly1gq7kw01vojj30lx0ow79i.jpg" alt=""><br>如图20所示，随着$c_1$的增大，图中出现了两个仅与左侧相连的气泡。20(a)由于Feigenbaum分岔，气泡演化成树并继续融合。在20(d)，由于树的融合，会产生一个周期为5的周期性窗口。最后，两棵树完全合并后，出现了（-0.9）分岔路径。</p>
<h3 id="B-改变串扰强度对吸引子类型的影响"><a href="#B-改变串扰强度对吸引子类型的影响" class="headerlink" title="B.改变串扰强度对吸引子类型的影响"></a>B.改变串扰强度对吸引子类型的影响</h3><p>当$k_1= 0.8, k_2= 1, a_1= 1, a_2= 7, b_1= 0.02, b_2= 0.03, c_2= 0.2$时，增加$c_1$时状态变量z的分叉图如图21(a)所示。相应的李雅普诺夫指数谱如图21(b)所示。<br><img src="https://tvax3.sinaimg.cn/mw690/005Au8gjly1gq7l7jxhcwj30r40ewn0z.jpg" alt=""></p>
<p><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gq7lbigehuj30q90q3tcv.jpg" alt=""></p>
<p>当其他条件和上面相同，$c_1=0.2$时，可以得到改变$c_2$状态变量z的分叉图。在图23中可以观察到间歇性混沌以及混沌与周期振荡之间的动力学行为变化，</p>
<p><img src="https://tvax1.sinaimg.cn/mw690/005Au8gjly1gq7lgelgaxj30qk0euq6d.jpg" alt=""></p>
<p>相图如图24所示。可以看出，系统产生了双涡旋混沌、周期振荡和单涡旋混沌。随着串扰强度c2的增加，该系统的吸引子类型由单卷变为双卷，再变为单卷。</p>
<p><img src="https://tvax3.sinaimg.cn/mw690/005Au8gjly1gq7lin3hnxj30qn0pk0wq.jpg" alt="image"></p>
<h2 id="七、仿真"><a href="#七、仿真" class="headerlink" title="七、仿真"></a>七、仿真</h2><p>利用PSIM进行仿真。与理论分析部分结果一致，略。</p>
]]></content>
      <categories>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>复杂网络</tag>
        <tag>拓扑识别</tag>
        <tag>同步，复杂动力学</tag>
      </tags>
  </entry>
  <entry>
    <title>多稳态忆阻及其在神经网络中的应用（及两篇引文）</title>
    <url>/2021/04/26/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="多稳态忆阻及其在神经网络中的应用"><a href="#多稳态忆阻及其在神经网络中的应用" class="headerlink" title="多稳态忆阻及其在神经网络中的应用"></a>多稳态忆阻及其在神经网络中的应用</h1><p>A Multi-Stable Memristor and Its Application in a Neural Network<br><span id="more"></span><br>IEEE TRANSACTIONS ON CIRCUITS AND SYSTEMS<br><a href="https://maiimg.com/pdf/?e=agFURqFOchWOQm">https://maiimg.com/pdf/?e=agFURqFOchWOQm</a> (该链接仅供学习用途)</p>
<h2 id="一、摘要"><a href="#一、摘要" class="headerlink" title="一、摘要"></a>一、摘要</h2><p>&emsp;&emsp;目前，关于基于忆阻的<em>多稳态系统</em>有很多研究。然而，目前还没有关于多稳态忆阻的研究。本文建立了一个具有多稳态的忆阻数学模型。利用标准非线性理论以及电路和系统理论揭示了多稳态动力学的起源。此外，利用多稳态记忆电阻器模拟Hopfield神经网络中的突触连接。忆阻神经网络成功地产生了<strong>无穷多个共存的混沌吸引子</strong>，这在以前传统的hopfield神经网络中是没有发现的。这一结果也在基于商用电子元件的模拟电路中得到证实。</p>
<h2 id="二、intro"><a href="#二、intro" class="headerlink" title="二、intro"></a>二、intro</h2><p>略</p>
<h2 id="三、多稳态模型"><a href="#三、多稳态模型" class="headerlink" title="三、多稳态模型"></a>三、多稳态模型</h2><p>根据忆阻器理论，压控通用忆阻器模型可以定义为<br>欧姆定律：</p>
<script type="math/tex; mode=display">i = G(x)v</script><p>状态方程：</p>
<script type="math/tex; mode=display">dx/dt=g(x,v)</script><p>式中$G(x)$为memductance（忆感）, $v, i, x$分别为电压, 电流，忆阻状态。基于上面两个式子，提出了一个通用的忆阻模型，即</p>
<p><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gpxccm0wpzj30b302gq2w.jpg" alt=""></p>
<p>在忆阻外部加一个正弦激励：</p>
<script type="math/tex; mode=display">V=AsinFt</script><p>再将状态方程积分可得：<br><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gpxckma8bzj30es03ut8t.jpg" alt=""></p>
<p>带入欧姆方程可得：</p>
<p><img src="https://tvax3.sinaimg.cn/mw690/005Au8gjly1gpxcli5cm4j30lk03hglw.jpg" alt=""></p>
<p>很显然是由一个基频和谐波分量组成。</p>
<h3 id="伏安特性"><a href="#伏安特性" class="headerlink" title="伏安特性"></a>伏安特性</h3><p>用磁滞回路图描述，前一个图是振幅A变化的时候，回路图的变化。后一个图是F变化的时候的回路图，F越大越接近纯直线。</p>
<p><img src="https://tvax3.sinaimg.cn/mw690/005Au8gjly1gpx9cbqojfj30nb0b2dis.jpg" alt=""></p>
<h3 id="多稳态特性"><a href="#多稳态特性" class="headerlink" title="多稳态特性"></a>多稳态特性</h3><p>令v=0，忆阻的状态方程就化为了如下：<br><img src="https://tva1.sinaimg.cn/mw690/005Au8gjly1gpxanoh6dfj309u01h0sl.jpg" alt=""></p>
<p>多稳态忆阻器的POP，其中k为偶数。（本文利用激励中断图(POP)来揭示忆阻器的多重稳定性），具体原理不用知道，只需要知道奇稳定，偶不稳定即可。</p>
<p><img src="https://tvax2.sinaimg.cn/mw690/005Au8gjly1gpx9xzex6oj30hj0e5jw2.jpg" alt=""></p>
<p>下图是不同初始态下忆阻多稳态向不同稳态的时间演化。</p>
<p><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gpx9z0drahj30hy0dn7a7.jpg" alt=""></p>
<p>此图可以印证上图的正确性。当k为偶数时，平衡点是不稳定的，而平衡点$S<em>{k+1}$是稳定的。因此，对于初态$x_0∈(kπ， (k + 2)π)$，忆阻态趋向于稳定平衡点$x(S</em>{k+1})$，即</p>
<p><img src="https://tvax1.sinaimg.cn/mw690/005Au8gjly1gpxayr34rcj30k701daa0.jpg" alt=""><br>上式直接说明了两个重要的结果:<br>(i)对于不同的初始状态，k值不同，多稳态忆阻器的动力学轨迹会趋向不同的稳定平衡点，即多稳态。<br>(ii)对于具有相同k的不同初始态，多稳态忆阻器的动态轨迹将趋于相同的稳定平衡点，即可调性。</p>
<p>下图是多稳态忆阻器不同初始状态下$x_0$=−7π、−5π、−3π、−1π、1π、3π、5π和7π的数值模拟结果。(a)Memductances (b)共存的收缩磁滞回线<br><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gpxauzfamcj30mv0afwjt.jpg" alt=""><br><img src="https://tvax2.sinaimg.cn/mw690/005Au8gjly1gpxc4zatpdj30gg0cr0xl.jpg" alt=""><br>由图可知，对于不同的初始状态范围$x_0∈(kπ， (k + 2)π)$，其中$k$为任意偶数，多稳态忆阻器可以同时产生无穷多个磁滞环。表明忆阻在直流电激励下表现出多种稳定状态的行为。</p>
<h2 id="四、Hopfield"><a href="#四、Hopfield" class="headerlink" title="四、Hopfield"></a>四、Hopfield</h2><p>Hopfield神经网络的节点电流方程如下：<br><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gpx6m4x5pfj30jc03agln.jpg" alt=""><br>注： $w_{ij}$ 的单位为西门子。</p>
<p>忆阻神经网络的拓扑结构图：<br><img src="https://tva1.sinaimg.cn/mw690/005Au8gjly1gpx65stf7sj30fw0bfdia.jpg" alt=""></p>
<p>令$C<em>i=1,R_i=1,I_i=0$,该带忆阻神经网络的方程如下：<br><img src="https://tvax2.sinaimg.cn/mw690/005Au8gjly1gpx6k99xd9j30lm06b750.jpg" alt=""><br>其中$G=z$ 代表 $\omega</em>{41}$ ，$\rho$ 代表耦合强度。当神经网络的所有权值都为0的时候，有无数个离散平衡点。</p>
<p>分岔图和Lyapunov指数图，其中$\rho$的变化范围是从0-5，节点的初始状态为$(1,1,1,1,1)$。可以看出当 $\rho&gt;2.8$的时候，神经网络进入稳定混沌状态。<br><img src="https://tva1.sinaimg.cn/mw690/005Au8gjly1gpx694zu95j30wu0chtin.jpg" alt=""><br>Lyapunov指数，混沌系统的基本特点就是系统对初始值的极端敏感性，两个相差无几的初值所产生的轨迹，随着时间的推移按指数方式分离，lyapunov指数就是定量的描述这一现象的量。Lyapunov指数是衡量系统动力学特性的一个重要定量指标,它表征了系统在相空间中相邻轨道间收敛或发散的平均指数率。<strong>对于系统是否存在动力学混沌, 可以从最大Lyapunov指数是否大于零非常直观的判断出来</strong>: 一个正的Lyapunov指数,意味着在系统相空间中,无论初始两条轨线的间距多么小,其差别都会随着时间的演化而成指数率的增加以致达到无法预测,这就是混沌现象。</p>
<p>下图分别表示当$\rho=0.7,1.5,2.2,4$的时候的数值仿真相图，也就是吸引子的图，由下图可以看出当$\rho=4$的时候将不是周期性的吸引子而是混沌吸引子。<br><img src="https://tva3.sinaimg.cn/mw690/005Au8gjly1gpx76pz7vqj30lp07kadj.jpg" alt=""></p>
<p>在多稳态忆阻耦合强度$\rho=4$固定的情况下，记忆神经网络可以在不同初始状态下产生无穷多个共存的混沌吸引子。以下是改变$z_0$的情况下，产生的混沌吸引子对比图和zmax图，Lyapunov指数图。<br><img src="https://tvax3.sinaimg.cn/mw690/005Au8gjly1gpx7ktw1f3j30u20ddqf6.jpg" alt=""></p>
<p>下图直接展示了两个重要的现象:</p>
<p>(i)忆阻神经网络随着 $z_0$ 的增大产生了无限多个不同位置的混沌吸引子;</p>
<p>(ii)每个吸引子都有一个独立的初始状态范围 $z_0∈(kπ，(k + 2)π)$，其中k为偶数。<br>显然，每个吸引子的位置和初始状态都是可调的。这意味着该神经网络中的多稳态动力学是可控的。</p>
<p><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gpx7peluwxj30v00dyn2m.jpg" alt=""></p>
<h2 id="五、优点和不足点"><a href="#五、优点和不足点" class="headerlink" title="五、优点和不足点"></a>五、优点和不足点</h2><ol>
<li>设计了比较新颖的多稳态忆阻</li>
<li>比较详细的说明了当z0变化的时候，吸引子位置的变化，并且通过混沌吸引子图，分岔图和Lyapunov指数图进行了说明。</li>
<li>没有调整吸引子的初始状态，文章将初始向量设为了同一个，也就是没考虑可能的极限环情况。</li>
</ol>
<h1 id="基于忆阻的Hopfield神经网络中的嵌合现象"><a href="#基于忆阻的Hopfield神经网络中的嵌合现象" class="headerlink" title="基于忆阻的Hopfield神经网络中的嵌合现象"></a>基于忆阻的Hopfield神经网络中的嵌合现象</h1><p>Dynamic behaviors of hyperbolic-type memristor-based Hopfield neural network considering synaptic crosstalk<br>The European Physical Journal Special Topics<br><a href="https://maiimg.com/pdf/?e=agdq/JHoVhyVkm">https://maiimg.com/pdf/?e=agdq/JHoVhyVkm</a> （该链接仅供学习用途）</p>
<h2 id="一、摘要-1"><a href="#一、摘要-1" class="headerlink" title="一、摘要"></a>一、摘要</h2><p>忆阻器在各个领域显示出巨大的潜力，可以产生新的特性。因此，基于记忆电阻的系统正在得到广泛的应用研究。本文研究了一种新的基于记忆电阻的双曲型Hopfield神经网络，作为耦合网络的单个单元。特别地，研究了系统各状态变量之间的耦合对网络行为的影响。结果表明，在不同的耦合强度下，耦合变量的变化会产生不同的系统模式，包括部分嵌合态、嵌合态、同步、不完全同步和振荡死亡。当基于记忆电阻的元件相互耦合时，增加耦合强度会导致从异步状态到嵌合体状态的规律性转变，然后再向同步状态转变。</p>
<h2 id="二、intro-1"><a href="#二、intro-1" class="headerlink" title="二、intro"></a>二、intro</h2><p>同步态<br>嵌合状态：同步的一个非常特殊的现象，结合相干和非相干两种状态的混合状态可以自发地出现<br>部分嵌合状态<br>振荡死亡态：在一定条件下，整个耦合振子系统可以停止振荡并转移到一个全局非均匀的定态（即所谓的振荡死亡态）。</p>
<h2 id="三、建模"><a href="#三、建模" class="headerlink" title="三、建模"></a>三、建模</h2><p>忆阻HNN的拓扑结构如下：<br><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gpxgq109ebj30i30gugrk.jpg" alt=""></p>
<p>连接矩阵如下：<br><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gpxgvdultvj30jj05574k.jpg" alt=""></p>
<p>基于忆阻的HNN的常微分方程(ode)为:<br><img src="https://tva3.sinaimg.cn/mw690/005Au8gjly1gpxgy06ghrj30pk068wf9.jpg" alt=""></p>
<p>其中，突触权重$w_{13}$定义为 $kW = k(a−b tanh(x_4))$ ， $k$为三个神经元的耦合强度。通过对$a、b、k$的参数选择不同的值，系统可以表现出不同的共存极限环吸引子和奇异吸引子，其中部分如下图所示。<br><img src="https://tva2.sinaimg.cn/large/005Au8gjly1gpxhl4i2gaj30t20jawlf.jpg" alt=""><br>其中a、b图里，蓝色为吸引子，红色为极限环，c图均为吸引子，d图蓝色为极限环，红色为定点。</p>
<p>a) $a = 1,b=0.41,k=0.8$，可知此时有两个吸引区域。</p>
<p>各个神经网络变量间耦合的网络方程为:<br><img src="https://tva4.sinaimg.cn/mw690/005Au8gjly1gpxh2ywofuj312h0g5q52.jpg" alt=""></p>
<p>其中 $[\dot{x}<em>{1i},\dot{x}</em>{2i},\dot{x}<em>{3i},\dot{x}</em>{4i}]$ 表示第i个单元的状态变量。每个基于记忆电阻的HNN节点对称地耦合到其最近的2P个节点。d1，…， d4为耦合强度。</p>
<h2 id="四、仿真与结果"><a href="#四、仿真与结果" class="headerlink" title="四、仿真与结果"></a>四、仿真与结果</h2><p>系统参数固定为$a = 1,b=0.41,k=0.8$。由上图每个单元都有一个极限环和一个混沌吸引子共存。在构建网络时，N=100个HNN被耦合，P=30。在所有的模拟中，初始条件是从两个吸引盆地（这个翻译比较形象）中随机选择的。</p>
<h3 id="x-1-状态变量耦合"><a href="#x-1-状态变量耦合" class="headerlink" title="$x_1$状态变量耦合"></a>$x_1$状态变量耦合</h3><p>首先设置$x_1$状态变量之间的耦合(即d2=d3=d4=0)，通过增加耦合强度d1，网络的数值模拟如下图所示。</p>
<p><img src="https://tva1.sinaimg.cn/mw690/005Au8gjly1gpxi3n1kg3j311t16ye82.jpg" alt=""></p>
<p>由上图，当耦合强度较小时，网络动态是完全不相干的。左图是100个HNN网络的时空模式图，右图是极限环。</p>
<pre><code>(a) d1= 0.01时的异步性
(b) d1= 0.05时的异步性
(c) d1= 0.1时的部分嵌合状态
(d) d1= 0.5时的部分嵌合状态
</code></pre><p><img src="https://tvax2.sinaimg.cn/mw690/005Au8gjly1gpxibpx1raj313h0cjn5b.jpg" alt=""><br>上图是完全对应于图三的某个时间节点的快照。 ？</p>
<h3 id="x-2-状态变量耦合"><a href="#x-2-状态变量耦合" class="headerlink" title="$x_2$状态变量耦合"></a>$x_2$状态变量耦合</h3><p>设置$x_2$状态变量之间的耦合(即d1=d3=d4=0)，通过增加耦合强度d2，网络的数值模拟如下图所示。</p>
<p><img src="https://tvax2.sinaimg.cn/mw690/005Au8gjly1gpy1t1ud7ij30ze16eb29.jpg" alt=""></p>
<p>由图，当耦合强度较小时，网络完全同步。如果提高耦合强度，所有振子都会被不动点吸引，模式是非相干振荡死亡。纯色是非相干振荡死亡，条纹是相干震荡。</p>
<pre><code>(a)d2 = 0.01时同步
(b)d2 = 0.1时相干振荡死亡和非相干振荡共存
(c)d2 = 0.3时部分嵌合状态
(d)d2 = 0.8时非相干振荡死亡。
</code></pre><p><img src="https://tvax1.sinaimg.cn/mw690/005Au8gjly1gpy21no1shj314g0d0gs7.jpg" alt=""></p>
<h3 id="x-3-状态变量耦合"><a href="#x-3-状态变量耦合" class="headerlink" title="$x_3$状态变量耦合"></a>$x_3$状态变量耦合</h3><p>设置$x_3$状态变量之间的耦合，增加耦合强度d3，网络的数值模拟如下图所示。</p>
<p><img src="https://tva4.sinaimg.cn/mw690/005Au8gjly1gpy25byd0fj30rt149e81.jpg" alt=""></p>
<pre><code>(a)d3 = 0.005时的不同步
(b)d3 = 0.01时的嵌合状态
(c)d3 = 0.1时的嵌合状态
(d)d3 = 0.2时的不完全同步
(e)d3 = 0.3时的同步
</code></pre><p><img src="https://tva3.sinaimg.cn/mw690/005Au8gjly1gpy2czj93nj310f0hb46a.jpg" alt=""></p>
<h3 id="x-4-状态变量耦合"><a href="#x-4-状态变量耦合" class="headerlink" title="$x_4$状态变量耦合"></a>$x_4$状态变量耦合</h3><p>设置$x_4$状态变量之间的耦合，增加耦合强度d4，网络的数值模拟如下图所示。<br>观察到网络对于耦合强度d4的<strong>所有值都是异步的</strong>，并且没有出现同步或嵌合状态.</p>
<p><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gpy2fms9ofj30wt12mu0x.jpg" alt=""></p>
<p>(a) d4= 0.1<br>(b) d4= 0.3<br>(c) d4= 0.5<br>(d) d4= 0.8</p>
<p><img src="https://tvax3.sinaimg.cn/mw690/005Au8gjly1gpy2hhkbb7j30zb0b8jym.jpg" alt=""></p>
<h2 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h2><p>$x_1$为耦合变量时，通过增加耦合强度出现异步和部分嵌合状态。<br>当耦合变量变为$x_2$时，网络对于小耦合强度是同步的，通过提高耦合强度，振子的吸引子从极限环转换为不动点。首先，观察到相干振荡死亡区和非相干振荡共存。然后非相干振荡变成相干的，最后在高耦合强度下，所有的吸引子都是不动点，并且观察到振荡死亡状态。<br>耦合变量变为包含忆阻器的$x_3$时，耦合强度的增加导致从异步状态到嵌合状态的转变，然后到不完全同步，最后完全同步。<br>$x_4$为耦合变量时，网络只是表现出异步振荡。<br>因此可以知道，不同的神经网络的耦合强度不同的时候，神经网络之间的同步嵌合状态是不一样的。</p>
]]></content>
      <categories>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>忆阻</tag>
        <tag>多稳态</tag>
        <tag>文献阅读</tag>
        <tag>复杂动力学</tag>
      </tags>
  </entry>
  <entry>
    <title>《乌鸦》歌曲分析</title>
    <url>/2021/05/07/%E8%AE%B8%E5%B5%A9%E5%8D%95%E6%9B%B2%E4%B9%8C%E9%B8%A6/</url>
    <content><![CDATA[<h1 id="《乌鸦》歌曲分析"><a href="#《乌鸦》歌曲分析" class="headerlink" title="《乌鸦》歌曲分析"></a>《乌鸦》歌曲分析</h1><p>许老师第八张专辑首支发布的单曲《乌鸦》，风格安静恬淡。融入了比普通流行音乐更多的古典配器、和声、织体的元素，配器为交响乐团的弦乐组和木管组以及一些现代乐队的乐器。<span id="more"></span>前奏和主歌融入了很多离调的元素，因此初听到前奏的时候让我耳前一亮。副歌则回归正常的许式流行风格，充分照顾了大众听众的听感。个人觉得是一首非常优秀的单曲，耐听且不会觉得乏味。</p>
<p>调式为F大调。</p>
<h2 id="和声分析"><a href="#和声分析" class="headerlink" title="和声分析"></a>和声分析</h2><p><strong>前奏部分（0：00-0：28）：</strong><br>前奏$I_M$进入，奠定歌曲基调，五音在低音因此是第二转位。<br>然后$III_M$-$II_m$-$V_M$，虽然有调外音（$III_M$的三音），但是也是比较经典的流行和声进行。比较巧妙的是，中声部钢琴在每个和弦演奏完后，非常突出的演奏了一段升音阶，其中不乏半音阶等踩和弦外音的音阶，这就给原本普通的和弦进行增加了一丝鬼魅的色彩。</p>
<p><strong>主歌部分（0：29-1：20）：</strong><br>和声最为丰富的一个部分。和弦进行如下<br>$I_M$-$I_m$（短暂）-$V_M$-$III_M$-$VI_m$-$IV_M$-$IV_m$-$I_M$-$VI_m$-$III_m$-$VI_m$-$II_M$-$V_M$<br>紧接着突然接了一个F小调降音阶，转为了对应关系小调。</p>
<p><strong>副歌部分（1：21-2:13）：</strong>（注：以下和弦均未考虑色彩音如add、sus）<br>副歌部分的和弦进行回归流行<br>$I_M$-$III_M$-$VI_m$-$V_m$-$IV_M$-$V_M$-$III_m$-$II_m$-$V_M$<br>此时插入一个小调下行音阶。<br>$I_M$-$III_M$-$VI_m$-$V_m$-$IV_M$-$V_M$-$III_m$-$II_M$-$IV_m$-$I_M$。</p>
<p>本歌曲相比于许老师之前的歌，在和声上有了一些改变。<br>首先介绍一个概念，下图是C大调：<br><img src="https://tvax1.sinaimg.cn/large/005Au8gjgy1gqaugqanwmj30he034wee.jpg" alt="C大调"><br>下图是C自然小调<br><img src="https://tva3.sinaimg.cn/large/005Au8gjgy1gqaui2kv0oj30h803ft8n.jpg" alt="C小调"><br>将其称作对应关系大小调（虽然基础乐理里面关系大小调的定义是另外的意思，但在这我还是这样称呼它）。</p>
<p>本歌曲中多次用到了对应关系大小调进行离调处理，给歌曲增加古典色彩。<br>在C大调下，标准的和弦为$C_M$、$D_m$、$E_m$、$F_M$、$G_M$、$A_m$、$Bdim$,分别对应1-7级和弦。<br>比如主歌部分和弦进行就多次应用这种技巧，比如流行音乐常用的$III_M$和弦，比如相对而言不太常用的$I_m$、$IV_m$、$II_M$。比如时不时演奏的F小调音阶。<br>结合歌曲的主题，就可以发现许老师设计的相当巧妙。大调音阶在这首歌中相当于主流，小调音阶则是夹杂其中的非主流因素。</p>
<h2 id="配器分析"><a href="#配器分析" class="headerlink" title="配器分析"></a>配器分析</h2><p>主要部分的配器以钢琴为主，弦乐，木管乐器为辅。<br>后期加入了简单的架子鼓和bass甚至电吉他人声和声增强厚度。</p>
<p>编写比较出彩的乐器片段分别为<br>前奏部分（0：00-0：28）很抓耳<br>0：51处穿插的钢琴小调音阶<br>0：54-1：20弦乐双簧管长笛<br>1：19处钢琴连续的柱式和弦<br>2：13-2：26——低鸣的巴松和颇具古典色彩的钢琴<br>后面的bass编写的也还行。<br>其余乐器均属于正常水平。</p>
<h2 id="BB"><a href="#BB" class="headerlink" title="BB"></a>BB</h2><p>很喜欢这种颇具古典色彩的音乐。上一张《寻宝游戏》里，许老师一头扎入了美式的布鲁斯里面，带着布鲁斯老炮的气质摇摇晃晃潇潇洒洒的写歌。这一张第一首则回归了世界流行音乐的鼻祖，古典音乐，写的严谨，典雅，略带忧伤。《乌鸦》是一只足够优秀的单曲，期待专辑后续的歌。</p>
]]></content>
      <categories>
        <category>歌曲分析</category>
      </categories>
      <tags>
        <tag>和声</tag>
        <tag>配器</tag>
      </tags>
  </entry>
  <entry>
    <title>重配爵士和声教程（一）</title>
    <url>/2021/01/28/%E9%87%8D%E9%85%8D%E5%92%8C%E5%A3%B0%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="如何重配和声（笔记）"><a href="#如何重配和声（笔记）" class="headerlink" title="如何重配和声（笔记）"></a>如何重配和声（笔记）</h1><p>注：重配和声  =  和弦替代</p>
<p>重配和声被用于：<span id="more"></span></p>
<ul>
<li>让一首歌爵士化，即丰富其和声，让它的结构复杂</li>
<li>使歌曲更富有个人色彩</li>
</ul>
<p>歌曲的普遍结构=旋律线 + 和声进行，重配和声包括改变歌曲的旋律线和和声，此改变要基于一定的规则和概念。</p>
<h2 id="重配和声分为以下两个方面："><a href="#重配和声分为以下两个方面：" class="headerlink" title="重配和声分为以下两个方面："></a>重配和声分为以下两个方面：</h2><ol>
<li>和弦<ol>
<li>旋律和和弦之间相互作用要合理</li>
<li>取决于和弦的种类</li>
<li>基音必须是所选和弦中的一个可用音</li>
</ol>
</li>
<li>结构（包括和弦结构和低音线条）<ol>
<li>不受和弦种类的影响</li>
<li>结构必须合理   </li>
</ol>
</li>
</ol>
<p><strong>重配和弦的步骤</strong></p>
<ol>
<li>找出基音</li>
</ol>
<p><img src="https://tva4.sinaimg.cn/large/0083jUChgy1gn2sncftjwj30dz07n76q.jpg" alt="avatar"></p>
<p>上图中红圈中圈出来的是基音</p>
<h2 id="和声"><a href="#和声" class="headerlink" title="和声"></a>和声</h2><ol>
<li>改变和弦或者基音以确保基音是一个可接受和弦音</li>
<li>可接受和弦音加强了和声的质量，提升了歌曲的一致性</li>
<li>和弦音按照其在和弦中的功能可以被分成“弱和声效果音（以下简称弱效音）”，“强和声效果音（以下简称强效音）”，“爵士效果音（以下简称爵味音）”和“不和谐音”。<ul>
<li>根音和纯五度是弱效音</li>
<li>三音，七音和增减无毒音是强效音. </li>
</ul>
</li>
</ol>
<p>下表以C的所有和弦为例，列出了十二音体系中的所有音对于和弦的和声特性：</p>
<p><img src="https://tvax2.sinaimg.cn/large/0083jUChgy1gn2sp9vlm6j30jt0iwdj1.jpg" alt=""></p>
<p>下表是当基音为C时，所有根音的所有和弦对于它的和声效果。<br><img src="https://tva4.sinaimg.cn/large/0083jUChgy1gn2spuao5ej30lz08wt9h.jpg" alt=""></p>
<p><a href="http://www.thejazzpianosite.com/jazz-piano-lessons/jazz-reharmonization/how-to-reharmonize-a-song/（图源）">http://www.thejazzpianosite.com/jazz-piano-lessons/jazz-reharmonization/how-to-reharmonize-a-song/（图源）</a></p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ol>
<li>考虑结构的时候可以忽略和弦的种类</li>
<li>使一个和弦/低音通过结构化的方式向下一个移动，具体如下：<ul>
<li>固定的音程间隔</li>
<li>沿着特定调性</li>
<li>沿着旋律线条</li>
</ul>
</li>
</ol>
<p><strong>固定间隔的种类</strong></p>
<p>音程    和弦进行举例<br>半音阶(Chromatic)    Eb7 - D7 - Db7 - CMaj7<br>全音阶    F#7 - E7 - Dm7 - CMaj7<br>小三度    Am7 - F#7 - Eb7 - CMaj7<br>大三度(Coltrane)    CMaj7 - AMaj7 - EMaj7 - CMaj7<br>纯四度（逆时针五度圈）    EbMaj7 - BbMaj7 - FMaj7 - CMaj7<br>三全音    F#7 - C7 - F#7 - C7<br>纯五度（顺时针五度圈）    A7 - Dm7 - G7 - CMaj7<br>so on…(上行下行皆可)    </p>
<p><strong>基于特定调式</strong></p>
<p>音程    和弦进行<br>固定音程    F7 - E7 - D7 - CMaj7<br>B7 - G7 - E7 - C7<br>五度圈    F7 - B7 - E7 - A7 - D7 - G7 - C7</p>
<h2 id="低音线条"><a href="#低音线条" class="headerlink" title="低音线条"></a>低音线条</h2><ul>
<li>可以通过转位和弦创造平滑的低音线条，使得低音不出现跳进</li>
<li>低音线条同样遵循结构的规则 - 固定的音程间隔，沿着某种调式，沿着旋律线条</li>
<li>低音线条和和弦的根音可以根据不同的方式进行，只要他们都遵循特定的结构且合理即可</li>
</ul>
<p><img src="https://tva4.sinaimg.cn/large/0083jUChgy1gn2sr2y1zjj30eb08241t.jpg" alt=""></p>
<h2 id="其他规则-注意事项"><a href="#其他规则-注意事项" class="headerlink" title="其他规则/注意事项"></a>其他规则/注意事项</h2><ul>
<li>通过选择和弦来增加或者减少紧张感<ul>
<li>增加紧张感——高阶延申音和变化音</li>
<li>减少紧张感——3音、7音和低阶延申音（如属9音）</li>
</ul>
</li>
<li>在旋律音时值长且重复多次时，可以改变和弦</li>
<li>如果和声进行有很强的结构性的时候，可以选择旋律音是弱效音的和弦</li>
<li>如果有旋律音是强效音的时候，那么结构这方面可以稍微弱化一点</li>
<li>如果旋律音是一串连续音符，找不出明显的基音，结构这时候比和声重要</li>
</ul>
]]></content>
      <categories>
        <category>和声学学习</category>
      </categories>
      <tags>
        <tag>和声学</tag>
        <tag>爵士和弦</tag>
        <tag>乐理</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;从前慢&gt;和声改编</title>
    <url>/2021/05/22/%E4%BB%8E%E5%89%8D%E6%85%A2%E5%92%8C%E5%A3%B0%E9%87%8D%E9%85%8D/</url>
    <content><![CDATA[<h1 id="lt-从前慢-gt-和声改编"><a href="#lt-从前慢-gt-和声改编" class="headerlink" title="&lt;从前慢&gt;和声改编"></a>&lt;从前慢&gt;和声改编</h1><p>由于听到的都是民谣版本，且这是个慢歌，比较好改编。选这首歌练一练关系大小调和声改编法。<span id="more"></span></p>
<p>记得早先少年时<br>1<br>大家诚诚恳恳<br>6       <font color=#0099ff >#1#37</font><br>说一句 是一句<br>  2 4m  1 3M<br>清早上火车站<br>6     b7dim<br>长街黑暗无行人<br>#4613  5613<br>卖豆浆的小店冒着热气<br>4 4m       1<br>从前的日色变得慢<br>1<br>车，马，邮件都慢<br>6<br>一生只够爱一个人<br>4     5   1 (1_7)<br>从前的锁也好看<br>1       3M<br>钥匙精美有样子<br>6</p>
<p>你锁了 人家就懂了<br>4    5  1 </p>
<font color=#0099ff >color=#0099ff size=72 face="黑体"</font>

<p>几个有意思的和弦：#1#37-2m/6-b7dim /#4613</p>
]]></content>
      <categories>
        <category>歌曲改编</category>
      </categories>
      <tags>
        <tag>和声</tag>
        <tag>改编</tag>
      </tags>
  </entry>
  <entry>
    <title>新冠前夕——不知道即将发生什么的120寝室</title>
    <url>/2021/05/22/%E6%96%B0%E5%86%A0%E5%89%8D%E5%A4%95/</url>
    <content><![CDATA[<h1 id="新冠前夕——不知道即将发生什么的120寝室"><a href="#新冠前夕——不知道即将发生什么的120寝室" class="headerlink" title="新冠前夕——不知道即将发生什么的120寝室"></a>新冠前夕——不知道即将发生什么的120寝室</h1><p>官方说明，坊间传闻已经够多了，我来说点身边的零碎。<br><span id="more"></span></p>
<p>人在东园，刚下食堂。天气晴，我和朋友准备开启属于学习的一天。</p>
<p>上午十点多某朋友给我发了几个微信截图，也就是早期的几个传图。当时看见了sars这个词，正在自习的我心一惊，顺手转发给了前后左右的（沙雕）同学。</p>
<p>然而我的朋友们看见了这些…表现出来了意想不到的平静。我怀疑她们是不是不知道什么是sars，或者把它当普通的无营养沙雕对话，只扫了一眼。我只能心里默默的骂她们憨憨，但也无可奈何，毕竟我也不知道消息是不是真的。</p>
<p>过了十几分钟，我的朋友们开始刷起了微博热搜，她们终于对这件事情有了一些感觉。她们意识到，噢，原来这是在武汉，会传染，诶好像我也是在武汉！但是紧接着她们又看到了新京报的辟谣，和各方的消息。她们已经意识到了事情可能比她们想象的严重，但由于觉得不会波及到自身，所以也只是情绪有轻微的起伏。</p>
<p>转折点出现在中午。本来我们只是想去超市散散步，顺便看看口罩。当我们踏进超市的一瞬间，就听见了那个比sars谣言还可怕的消息</p>
<p>‘口罩早已售空！’</p>
<p>我们的心态在那一时刻发生了变化，接下来我们看见的所有事情都是刺激，比如马路上戴口罩的人，比如小声交谈疫情的行人。。。</p>
<p>事不宜迟！我们取消了今天的复习计划，开始了寻找口罩的旅途。舆论上的不利消息在我们心中被无限放大，亲戚群里的那些谣言和截图，原本我们是非常不屑于相信的，现在它们，也显的真实了起来。这些信息在累积，在发酵，在折磨着买不到口罩的我。</p>
<p>‘天哪，又出现了新的聊天记录，还是个医生’</p>
<p>‘照片都出来了，防护服这么厚呀’</p>
<p>‘我医学院的同学都说有点严重了’</p>
<p>‘据说有患者证实了是sars’</p>
<p>不得不说那种时候，信息的快速便捷让我们进入了奇怪的境地，失去了理智。我们一刻也待不下去了，询问了自认为专业人士的亲戚后，我们开启了寻找口罩的旅程。</p>
<p>超市？肯定没有了，先去大药店看看！抄上车子，我们出发了 。不知道为什么，今天感觉同行的车子都变多了。一油门拧到底，可惜还是慢了一步。药店居然都没了！！</p>
<p>我们哪经历过这架势，口罩瞬间脱销，之前只是觉得口罩可有可无，现在，我们必须要买到！我们决定兵分两路，一路去医院，一路开始美团。</p>
<p>我是去医院的那一路。天哪，头一次见到医院有这么多人。可惜还没到下午上班的时间，只好等等。诶，那不是同班同学老余嘛。看着他戴着的高级崭新雪白的3m防雾霾口罩，我不禁小声叫出来了。时隔多日，我们的第一句寒暄居然不是学习，而是</p>
<p>‘你口罩哪买的呀’</p>
<p>害，这小子居然去年就买了，真聪明，我留下来不争气的泪水。过了一会，我们得知医院也没口罩了，人生顿时黯淡无光。朋友和我对视的时候，目光中充满了哀怨，仿佛两个loser在同病相怜。可能考试挂科都不会比这更让人难受。</p>
<p>另一拨小分队反馈美团也快凉了。</p>
<p>但她们在其他超市搞到了几只口罩，好歹可以撑两天了，不错。再加上抢到的最后两包并不具备抗病毒功能的板蓝根。嗯～大户人家，我们心满意足。</p>
<p>人类的快乐就是这么简单。那天晚上，我们不顾家人的劝阻，画了最精致的妆容，带着象征着荣耀和地位的淡蓝色医用口罩出门，在人来人往的地方吃了饭，玩了会。就像每一个普通的元旦一样，我们做着最普通的事情，戴着口罩。当然，不止是我们，大部分年轻人也都是这样，一边浸染在恐慌中，一边又仿佛无所畏惧，似乎恐慌本身也是一轮狂欢。</p>
<p>你要问目前的情况如何，我不是内部医务人员，我不知道。我只知道在这一天，大多数武汉普通人情况良好，除了钱包有点轻。我们也不能做什么，要让我们不信谣不传谣，可以，大学生了，道理我都懂。但是当看见飞奔向药店的人群，我还是会拉着周围人一起跟上去，好像那些人即将抢走最后一片口罩。</p>
<p>我们只是蜉蝣，有着高度群体性，有着人性的弱点，事件平息我们才能真正平息。我只能心里期待当局尽快控制疫情，及时更近进展，天佑中华，天佑武汉。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>Covid-19</tag>
      </tags>
  </entry>
</search>
