<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大步的Blog</title>
  
  
  <link href="http://www.liuxinlu.xyz/atom.xml" rel="self"/>
  
  <link href="http://www.liuxinlu.xyz/"/>
  <updated>2021-04-27T18:59:33.118Z</updated>
  <id>http://www.liuxinlu.xyz/</id>
  
  <author>
    <name>大步</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多稳态忆阻及其在神经网络中的应用（及两篇引文）</title>
    <link href="http://www.liuxinlu.xyz/2021/04/26/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    <id>http://www.liuxinlu.xyz/2021/04/26/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/</id>
    <published>2021-04-26T08:36:00.000Z</published>
    <updated>2021-04-27T18:59:33.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多稳态忆阻及其在神经网络中的应用"><a href="#多稳态忆阻及其在神经网络中的应用" class="headerlink" title="多稳态忆阻及其在神经网络中的应用"></a>多稳态忆阻及其在神经网络中的应用</h1><p>A Multi-Stable Memristor and Its Application in a Neural Network<br><span id="more"></span><br>IEEE TRANSACTIONS ON CIRCUITS AND SYSTEMS<br><a href="https://maiimg.com/pdf/?e=agFURqFOchWOQm">https://maiimg.com/pdf/?e=agFURqFOchWOQm</a> (该链接仅供学习用途)</p><h2 id="一、摘要"><a href="#一、摘要" class="headerlink" title="一、摘要"></a>一、摘要</h2><p>&emsp;&emsp;目前，关于基于忆阻的<em>多稳态系统</em>有很多研究。然而，目前还没有关于多稳态忆阻的研究。本文建立了一个具有多稳态的忆阻数学模型。利用标准非线性理论以及电路和系统理论揭示了多稳态动力学的起源。此外，利用多稳态记忆电阻器模拟Hopfield神经网络中的突触连接。忆阻神经网络成功地产生了<strong>无穷多个共存的混沌吸引子</strong>，这在以前传统的hopfield神经网络中是没有发现的。这一结果也在基于商用电子元件的模拟电路中得到证实。</p><h2 id="二、intro"><a href="#二、intro" class="headerlink" title="二、intro"></a>二、intro</h2><p>略</p><h2 id="三、多稳态模型"><a href="#三、多稳态模型" class="headerlink" title="三、多稳态模型"></a>三、多稳态模型</h2><p>根据忆阻器理论，压控通用忆阻器模型可以定义为<br>欧姆定律：</p><script type="math/tex; mode=display">i = G(x)v</script><p>状态方程：</p><script type="math/tex; mode=display">dx/dt=g(x,v)</script><p>式中$G(x)$为memductance（忆感）, $v, i, x$分别为电压, 电流，忆阻状态。基于上面两个式子，提出了一个通用的忆阻模型，即</p><p><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gpxccm0wpzj30b302gq2w.jpg" alt=""></p><p>在忆阻外部加一个正弦激励：</p><script type="math/tex; mode=display">V=AsinFt</script><p>再将状态方程积分可得：<br><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gpxckma8bzj30es03ut8t.jpg" alt=""></p><p>带入欧姆方程可得：</p><p><img src="https://tvax3.sinaimg.cn/mw690/005Au8gjly1gpxcli5cm4j30lk03hglw.jpg" alt=""></p><p>很显然是由一个基频和谐波分量组成。</p><h3 id="伏安特性"><a href="#伏安特性" class="headerlink" title="伏安特性"></a>伏安特性</h3><p>用磁滞回路图描述，前一个图是振幅A变化的时候，回路图的变化。后一个图是F变化的时候的回路图，F越大越接近纯直线。</p><p><img src="https://tvax3.sinaimg.cn/mw690/005Au8gjly1gpx9cbqojfj30nb0b2dis.jpg" alt=""></p><h3 id="多稳态特性"><a href="#多稳态特性" class="headerlink" title="多稳态特性"></a>多稳态特性</h3><p>令v=0，忆阻的状态方程就化为了如下：<br><img src="https://tva1.sinaimg.cn/mw690/005Au8gjly1gpxanoh6dfj309u01h0sl.jpg" alt=""></p><p>多稳态忆阻器的POP，其中k为偶数。（本文利用激励中断图(POP)来揭示忆阻器的多重稳定性），具体原理不用知道，只需要知道奇稳定，偶不稳定即可。</p><p><img src="https://tvax2.sinaimg.cn/mw690/005Au8gjly1gpx9xzex6oj30hj0e5jw2.jpg" alt=""></p><p>下图是不同初始态下忆阻多稳态向不同稳态的时间演化。</p><p><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gpx9z0drahj30hy0dn7a7.jpg" alt=""></p><p>此图可以印证上图的正确性。当k为偶数时，平衡点是不稳定的，而平衡点$S<em>{k+1}$是稳定的。因此，对于初态$x_0∈(kπ， (k + 2)π)$，忆阻态趋向于稳定平衡点$x(S</em>{k+1})$，即</p><p><img src="https://tvax1.sinaimg.cn/mw690/005Au8gjly1gpxayr34rcj30k701daa0.jpg" alt=""><br>上式直接说明了两个重要的结果:<br>(i)对于不同的初始状态，k值不同，多稳态忆阻器的动力学轨迹会趋向不同的稳定平衡点，即多稳态。<br>(ii)对于具有相同k的不同初始态，多稳态忆阻器的动态轨迹将趋于相同的稳定平衡点，即可调性。</p><p>下图是多稳态忆阻器不同初始状态下$x_0$=−7π、−5π、−3π、−1π、1π、3π、5π和7π的数值模拟结果。(a)Memductances (b)共存的收缩磁滞回线<br><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gpxauzfamcj30mv0afwjt.jpg" alt=""><br><img src="https://tvax2.sinaimg.cn/mw690/005Au8gjly1gpxc4zatpdj30gg0cr0xl.jpg" alt=""><br>由图可知，对于不同的初始状态范围$x_0∈(kπ， (k + 2)π)$，其中$k$为任意偶数，多稳态忆阻器可以同时产生无穷多个磁滞环。表明忆阻在直流电激励下表现出多种稳定状态的行为。</p><h2 id="四、Hopfield"><a href="#四、Hopfield" class="headerlink" title="四、Hopfield"></a>四、Hopfield</h2><p>Hopfield神经网络的节点电流方程如下：<br><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gpx6m4x5pfj30jc03agln.jpg" alt=""></p><p>忆阻神经网络的拓扑结构图：<br><img src="https://tva1.sinaimg.cn/mw690/005Au8gjly1gpx65stf7sj30fw0bfdia.jpg" alt=""></p><p>令$C<em>i=1,R_i=1,I_i=0$,该带忆阻神经网络的方程如下：<br><img src="https://tvax2.sinaimg.cn/mw690/005Au8gjly1gpx6k99xd9j30lm06b750.jpg" alt=""><br>其中$G=z$ 代表 $\omega</em>{41}$ ，$\rho$ 代表耦合强度。当神经网络的所有权值都为0的时候，有无数个离散平衡点。</p><p>分岔图和Lyapunov指数图，其中$\rho$的变化范围是从0-5，节点的初始状态为$(1,1,1,1,1)$。可以看出当 $\rho&gt;2.8$的时候，神经网络进入稳定混沌状态。<br><img src="https://tva1.sinaimg.cn/mw690/005Au8gjly1gpx694zu95j30wu0chtin.jpg" alt=""><br>Lyapunov指数 $\lambda$ 表示相空间相邻轨迹的平均指数发散率的数值特征。又称李雅普诺夫特征指数，是用于识别混沌运动若干数值的特征之一。</p><p>下图分别表示当$\rho=0.7,1.5,2.2,4$的时候的数值仿真相图，也就是吸引子的图，由下图可以看出当$\rho=4$的时候将不是周期性的吸引子而是混沌吸引子。<br><img src="https://tva3.sinaimg.cn/mw690/005Au8gjly1gpx76pz7vqj30lp07kadj.jpg" alt=""></p><p>在多稳态忆阻耦合强度$\rho=4$固定的情况下，记忆神经网络可以在不同初始状态下产生无穷多个共存的混沌吸引子。以下是改变$z_0$的情况下，产生的混沌吸引子对比图和zmax图，Lyapunov指数图。<br><img src="https://tvax3.sinaimg.cn/mw690/005Au8gjly1gpx7ktw1f3j30u20ddqf6.jpg" alt=""></p><p>下图直接展示了两个重要的现象:</p><p>(i)忆阻神经网络随着 $z_0$ 的增大产生了无限多个不同位置的混沌吸引子;</p><p>(ii)每个吸引子都有一个独立的初始状态范围 $z_0∈(kπ，(k + 2)π)$，其中k为偶数。<br>显然，每个吸引子的位置和初始状态都是可调的。这意味着该神经网络中的多稳态动力学是可控的。</p><p><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjly1gpx7peluwxj30v00dyn2m.jpg" alt=""></p><h2 id="五、创新点"><a href="#五、创新点" class="headerlink" title="五、创新点"></a>五、创新点</h2><ol><li>设计了多稳态忆阻。</li></ol><h1 id="基于忆阻的Hopfield神经网络中的嵌合现象"><a href="#基于忆阻的Hopfield神经网络中的嵌合现象" class="headerlink" title="基于忆阻的Hopfield神经网络中的嵌合现象"></a>基于忆阻的Hopfield神经网络中的嵌合现象</h1><p>Dynamic behaviors of hyperbolic-type memristor-based Hopfield neural network considering synaptic crosstalk<br>The European Physical Journal Special Topics<br><a href="https://maiimg.com/pdf/?e=agdq/JHoVhyVkm">https://maiimg.com/pdf/?e=agdq/JHoVhyVkm</a> （该链接仅供学习用途）</p><h2 id="一、摘要-1"><a href="#一、摘要-1" class="headerlink" title="一、摘要"></a>一、摘要</h2><p>忆阻器在各个领域显示出巨大的潜力，可以产生新的特性。因此，基于记忆电阻的系统正在得到广泛的应用研究。本文研究了一种新的基于记忆电阻的双曲型Hopfield神经网络，作为耦合网络的单个单元。特别地，研究了系统各状态变量之间的耦合对网络行为的影响。结果表明，在不同的耦合强度下，耦合变量的变化会产生不同的模式，包括部分嵌合态、嵌合态、同步、不完全同步和振荡死亡。当基于记忆电阻的元件相互耦合时，增加耦合强度会导致从异步状态到嵌合体状态的规律性转变，然后再向同步状态转变。</p><h2 id="二、intro-1"><a href="#二、intro-1" class="headerlink" title="二、intro"></a>二、intro</h2><p>同步态<br>嵌合状态：同步的一个非常特殊的现象，结合相干和非相干两种状态的混合状态可以自发地出现<br>部分嵌合状态<br>振荡死亡态：在一定条件下，整个耦合振子系统可以停止振荡并转移到一个全局非均匀的定态（即所谓的振荡死亡态）。</p><h2 id="三、建模"><a href="#三、建模" class="headerlink" title="三、建模"></a>三、建模</h2><p>忆阻HNN的拓扑结构如下：<br><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gpxgq109ebj30i30gugrk.jpg" alt=""></p><p>连接矩阵如下：<br><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gpxgvdultvj30jj05574k.jpg" alt=""></p><p>基于忆阻的HNN的常微分方程(ode)为:<br><img src="https://tva3.sinaimg.cn/mw690/005Au8gjly1gpxgy06ghrj30pk068wf9.jpg" alt=""></p><p>其中，突触权重$w_{13}$定义为 $kW = k(a−b tanh(x_4))$ ， $k$为三个神经元的耦合强度。通过对$a、b、k$的参数选择不同的值，系统可以表现出不同的共存极限环吸引子和奇异吸引子，其中部分如下图所示。<br><img src="https://tva2.sinaimg.cn/large/005Au8gjly1gpxhl4i2gaj30t20jawlf.jpg" alt=""><br>其中a、b图里，蓝色为吸引子，红色为极限环，c图均为吸引子，d图蓝色为极限环，红色为定点。</p><p>a) $a = 1,b=0.41,k=0.8$，可知此时有两个吸引区域。</p><p>各变量间耦合的网络方程为:<br><img src="https://tva4.sinaimg.cn/mw690/005Au8gjly1gpxh2ywofuj312h0g5q52.jpg" alt=""></p><p>其中 $[\dot{x}<em>{1i},\dot{x}</em>{2i},\dot{x}<em>{3i},\dot{x}</em>{4i}]$ 表示第i个单元的状态变量。每个基于记忆电阻的HNN节点对称地耦合到其最近的2P个节点。d1，…， d4为耦合强度。</p><h2 id="四、仿真与结果"><a href="#四、仿真与结果" class="headerlink" title="四、仿真与结果"></a>四、仿真与结果</h2><p>系统参数固定为$a = 1,b=0.41,k=0.8$。由上图每个单元都有一个极限环和一个混沌吸引子共存。在构建网络时，N=100个HNN被耦合，P=30。在所有的模拟中，初始条件是从两个吸引盆地（这个翻译比较形象）中随机选择的。</p><h3 id="x-1-状态变量耦合"><a href="#x-1-状态变量耦合" class="headerlink" title="$x_1$状态变量耦合"></a>$x_1$状态变量耦合</h3><p>首先设置$x_1$状态变量之间的耦合(即d2=d3=d4=0)，通过增加耦合强度d1，网络的数值模拟如下图所示。</p><p><img src="https://tva1.sinaimg.cn/mw690/005Au8gjly1gpxi3n1kg3j311t16ye82.jpg" alt=""></p><p>由上图，当耦合强度较小时，网络动态是完全不相干的。左图是100个HNN网络的时空模式图，右图是极限环。</p><pre><code>(a) d1= 0.01时的异步性(b) d1= 0.05时的异步性(c) d1= 0.1时的部分嵌合状态(d) d1= 0.5时的部分嵌合状态</code></pre><p><img src="https://tvax2.sinaimg.cn/mw690/005Au8gjly1gpxibpx1raj313h0cjn5b.jpg" alt=""><br>上图是完全对应于图三的某个时间节点的快照。 ？</p><h3 id="x-2-状态变量耦合"><a href="#x-2-状态变量耦合" class="headerlink" title="$x_2$状态变量耦合"></a>$x_2$状态变量耦合</h3><p>设置$x_2$状态变量之间的耦合(即d1=d3=d4=0)，通过增加耦合强度d2，网络的数值模拟如下图所示。</p><p><img src="https://tvax2.sinaimg.cn/mw690/005Au8gjly1gpy1t1ud7ij30ze16eb29.jpg" alt=""></p><p>由图，当耦合强度较小时，网络完全同步。如果提高耦合强度，所有振子都会被不动点吸引，模式是非相干振荡死亡。纯色是非相干振荡死亡，条纹是相干震荡。</p><pre><code>(a)d2 = 0.01时同步(b)d2 = 0.1时相干振荡死亡和非相干振荡共存(c)d2 = 0.3时部分嵌合状态(d)d2 = 0.8时非相干振荡死亡。</code></pre><p><img src="https://tvax1.sinaimg.cn/mw690/005Au8gjly1gpy21no1shj314g0d0gs7.jpg" alt=""></p><h3 id="x-3-状态变量耦合"><a href="#x-3-状态变量耦合" class="headerlink" title="$x_3$状态变量耦合"></a>$x_3$状态变量耦合</h3><p>设置$x_3$状态变量之间的耦合，增加耦合强度d3，网络的数值模拟如下图所示。</p><p><img src="https://tva4.sinaimg.cn/mw690/005Au8gjly1gpy25byd0fj30rt149e81.jpg" alt=""></p><pre><code>(a)d3 = 0.005时的不同步(b)d3 = 0.01时的嵌合状态(c)d3 = 0.1时的嵌合状态(d)d3 = 0.2时的不完全同步(e)d3 = 0.3时的同步</code></pre><p><img src="https://tva3.sinaimg.cn/mw690/005Au8gjly1gpy2czj93nj310f0hb46a.jpg" alt=""></p><h3 id="x-4-状态变量耦合"><a href="#x-4-状态变量耦合" class="headerlink" title="$x_4$状态变量耦合"></a>$x_4$状态变量耦合</h3><p>设置$x_4$状态变量之间的耦合，增加耦合强度d4，网络的数值模拟如下图所示。<br>观察到网络对于耦合强度d4的<strong>所有值都是异步的</strong>，并且没有出现同步或嵌合状态.</p><p><img src="https://tva2.sinaimg.cn/mw690/005Au8gjly1gpy2fms9ofj30wt12mu0x.jpg" alt=""></p><p>(a) d4= 0.1<br>(b) d4= 0.3<br>(c) d4= 0.5<br>(d) d4= 0.8</p><p><img src="https://tvax3.sinaimg.cn/mw690/005Au8gjly1gpy2hhkbb7j30zb0b8jym.jpg" alt=""></p><h2 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h2><p>当$x_1$为耦合变量时，通过增加耦合强度出现异步和部分嵌合状态。<br>当耦合变量变为$x_2$时，网络对于小耦合强度是同步的，通过提高耦合强度，振子的吸引子从极限环转换为不动点。首先，观察到相干振荡死亡区和非相干振荡共存。然后非相干振荡变成相干的，最后在高耦合强度下，所有的吸引子都是不动点，并且观察到振荡死亡状态。<br>当耦合变量变为包含忆阻器的$x_3$时，耦合强度的增加导致从异步状态到嵌合状态的转变，然后到不完全同步，最后完全同步。<br>$x_4$为耦合变量时，网络只是表现出异步振荡。</p><h1 id="突触耦合的双曲型忆阻Hopfield神经网络的动力学行为"><a href="#突触耦合的双曲型忆阻Hopfield神经网络的动力学行为" class="headerlink" title="突触耦合的双曲型忆阻Hopfield神经网络的动力学行为"></a>突触耦合的双曲型忆阻Hopfield神经网络的动力学行为</h1><p>Dynamic behaviors of hyperbolic-type memristor-based Hopfield neural network considering synaptic crosstalk<br>Chaos 30, 033108 (2020 ); doi: 10.1063/5.0002076<br><a href="https://maiimg.com/pdf/?e=agS3v4tv8tYQ2m">https://maiimg.com/pdf/?e=agS3v4tv8tYQ2m</a> (该链接仅供学习用途)</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;多稳态忆阻及其在神经网络中的应用&quot;&gt;&lt;a href=&quot;#多稳态忆阻及其在神经网络中的应用&quot; class=&quot;headerlink&quot; title=&quot;多稳态忆阻及其在神经网络中的应用&quot;&gt;&lt;/a&gt;多稳态忆阻及其在神经网络中的应用&lt;/h1&gt;&lt;p&gt;A Multi-Stable Memristor and Its Application in a Neural Network&lt;br&gt;</summary>
    
    
    
    <category term="毕业设计" scheme="http://www.liuxinlu.xyz/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="神经网络" scheme="http://www.liuxinlu.xyz/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    <category term="忆阻" scheme="http://www.liuxinlu.xyz/tags/%E5%BF%86%E9%98%BB/"/>
    
    <category term="多稳态" scheme="http://www.liuxinlu.xyz/tags/%E5%A4%9A%E7%A8%B3%E6%80%81/"/>
    
    <category term="文献阅读" scheme="http://www.liuxinlu.xyz/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>人声混声踩坑指南（刚开坑）</title>
    <link href="http://www.liuxinlu.xyz/2021/04/20/%E4%BA%BA%E5%A3%B0%E6%B7%B7%E5%A3%B0%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://www.liuxinlu.xyz/2021/04/20/%E4%BA%BA%E5%A3%B0%E6%B7%B7%E5%A3%B0%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/</id>
    <published>2021-04-19T17:59:09.000Z</published>
    <updated>2021-04-27T16:22:13.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人声混声踩坑指南"><a href="#人声混声踩坑指南" class="headerlink" title="人声混声踩坑指南"></a>人声混声踩坑指南</h1><p>首先就是不能勾选音频栏的监听，因为我的麦克风自带声卡，如果再用电脑声卡将难以一起带动。<br><span id="more"></span></p><p>wavestune，一个非常好的校准音高的插件，但是建议自己手动修音。</p><p>混响目前感觉还是不是特别会。</p><p>消除气息可以直接用包络，降噪的方法目前还是不太会。</p><p>压缩效果器，compressor。<br><img src="https://tva3.sinaimg.cn/mw690/005Au8gjgy1gpjdicyhhwj30l70oxgr9.jpg" alt="image"></p><p>对齐不要选</p><p>粘合功能仅仅只是机械的将两段音频连接，没有灵魂</p><p><img src="https://tvax4.sinaimg.cn/mw690/005Au8gjgy1gpjiyk8dlfj314y0uewm0.jpg" alt="image"></p><p><img src="https://tva4.sinaimg.cn/mw690/005Au8gjgy1gpjj5bb5ygj314u0ug10d.jpg" alt="image"></p><p><img src="https://tva4.sinaimg.cn/mw690/005Au8gjgy1gpjkq2x8hij303x05ua9w.jpg" alt="image"></p><p>下一首翻唱曲目选择黄龄的醉。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;人声混声踩坑指南&quot;&gt;&lt;a href=&quot;#人声混声踩坑指南&quot; class=&quot;headerlink&quot; title=&quot;人声混声踩坑指南&quot;&gt;&lt;/a&gt;人声混声踩坑指南&lt;/h1&gt;&lt;p&gt;首先就是不能勾选音频栏的监听，因为我的麦克风自带声卡，如果再用电脑声卡将难以一起带动。&lt;br&gt;</summary>
    
    
    
    <category term="人声" scheme="http://www.liuxinlu.xyz/categories/%E4%BA%BA%E5%A3%B0/"/>
    
    
    <category term="vocal" scheme="http://www.liuxinlu.xyz/tags/vocal/"/>
    
    <category term="mix" scheme="http://www.liuxinlu.xyz/tags/mix/"/>
    
    <category term="daw" scheme="http://www.liuxinlu.xyz/tags/daw/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记——寻找两个正序数的中位数</title>
    <link href="http://www.liuxinlu.xyz/2021/02/02/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://www.liuxinlu.xyz/2021/02/02/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2021-02-02T06:47:56.000Z</published>
    <updated>2021-02-02T06:51:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>&emsp;&emsp;给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。<br><span id="more"></span></p><p>示例 1：</p><pre><code>输入：nums1 = [1,3], nums2 = [2]输出：2.00000</code></pre><p>示例 2：</p><pre><code>输入：nums1 = [1,2], nums2 = [3,4]输出：2.50000</code></pre><p>示例 3：</p><pre><code>输入：nums1 = [0,0], nums2 = [0,0]输出：0.00000</code></pre><p>示例 4：</p><pre><code>输入：nums1 = [], nums2 = [1]输出：1.00000</code></pre><p>示例 5：</p><pre><code>输入：nums1 = [2], nums2 = []输出：2.00000</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a></p><p>提示：</p><pre><code>nums1.length == mnums2.length == n0 &lt;= m &lt;= 10000 &lt;= n &lt;= 10001 &lt;= m + n &lt;= 2000-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></pre><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;此题很明显时间复杂度不会超过O(n),如果新建一个链表进行头插，那么空间复杂度为O(n)。现思考有没有空间复杂度为O(1)的解法，即在原本的链表基础上进行改动。</p><p>&emsp;&emsp;设定双指针pre和cur用于交换。而next作为中间指针保存cur.next的信息。算法图示如下：<br><img src="" alt="avatar"></p><p>具体代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        ListNode *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此题为大厂常考题目，建议熟记于心。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;反转链表&quot;&gt;&lt;a href=&quot;#反转链表&quot; class=&quot;headerlink&quot; title=&quot;反转链表&quot;&gt;&lt;/a&gt;反转链表&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。&lt;br&gt;</summary>
    
    
    
    <category term="Leetcode刷题笔记" scheme="http://www.liuxinlu.xyz/categories/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="http://www.liuxinlu.xyz/tags/C/"/>
    
    <category term="leetcode" scheme="http://www.liuxinlu.xyz/tags/leetcode/"/>
    
    <category term="数组" scheme="http://www.liuxinlu.xyz/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记——反转链表</title>
    <link href="http://www.liuxinlu.xyz/2021/01/31/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.liuxinlu.xyz/2021/01/31/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2021-01-31T05:43:19.000Z</published>
    <updated>2021-01-31T11:09:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>&emsp;&emsp;定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<br><span id="more"></span></p><p>示例:</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p>0 &lt;= 节点个数 &lt;= 5000</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;此题很明显时间复杂度不会超过O(n),如果新建一个链表进行头插，那么空间复杂度为O(n)。现思考有没有空间复杂度为O(1)的解法，即在原本的链表基础上进行改动。</p><p>&emsp;&emsp;设定双指针pre和cur用于交换。而next作为中间指针保存cur.next的信息。算法图示如下：<br><img src="https://tva1.sinaimg.cn/large/0083jUChgy1gn6xc46di9j30qt0j60uz.jpg" alt="avatar"></p><p>具体代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        ListNode *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此题为大厂常考题目，建议熟记于心。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;反转链表&quot;&gt;&lt;a href=&quot;#反转链表&quot; class=&quot;headerlink&quot; title=&quot;反转链表&quot;&gt;&lt;/a&gt;反转链表&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。&lt;br&gt;</summary>
    
    
    
    <category term="Leetcode刷题笔记" scheme="http://www.liuxinlu.xyz/categories/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="http://www.liuxinlu.xyz/tags/C/"/>
    
    <category term="leetcode" scheme="http://www.liuxinlu.xyz/tags/leetcode/"/>
    
    <category term="链表" scheme="http://www.liuxinlu.xyz/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>DP动态规划算法（未完）</title>
    <link href="http://www.liuxinlu.xyz/2021/01/28/DP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://www.liuxinlu.xyz/2021/01/28/DP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-01-28T04:28:27.000Z</published>
    <updated>2021-04-27T12:00:28.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h2 id="一、动态规划简介"><a href="#一、动态规划简介" class="headerlink" title="一、动态规划简介"></a>一、动态规划简介</h2><p>&emsp;&emsp;与分治法类似，即将待求解问题分解为若干子问题，先求解子问题，再由子问题的解得到原问题的解。<span id="more"></span>与分治法不同，它可以通过保存已解决子问题的答案来避免重复计算。加上记忆化之后相当于牺牲了一定的空间复杂度来换取时间复杂度。</p><script type="math/tex; mode=display">动态规划\left\{\begin{matrix} 递推求解 \\ 最大连续子序列和\\ 最大递增子序列和\\ 最大公共子序列\\ 背包问题 \end{matrix}\right.</script><p>动态规划两种方法：</p><p>1.递归策略+记忆法 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;  2.递推求解<br>（注：代码中最好不要出现递归，递归可能导致代码执行偏慢）</p><h2 id="一、最大连续子序列和"><a href="#一、最大连续子序列和" class="headerlink" title="一、最大连续子序列和"></a>一、最大连续子序列和</h2><p><strong>eg1.</strong> 给出一个整数序列S，其中有N个数，定义其中一个非空连续子序列T中所有数的和为T的“序列和”。 对于S的所有非空连续子序列T，求最大的序列和。 变量条件：N为正整数，N≤1000000，结果序列和在范围（-$2^ (63)$,$2^ (63)$-1）以内。</p><p>&emsp;&emsp;题目分析：本题如果采用最暴力的解法，即不固定子字符串首位，则遍历所有子序列的时间复杂度为O($n^2$)，求序列和的时间复杂度为O($n$)，总时间复杂度为O($n^3$).如果固定子序列尾部采用递归的手段，时间复杂度为O($n^2$)。<br>如果在递归的基础上加上记忆法，即动态规划的方法，时间复杂度可以降到O($n$)。同理，可以将此递归+记忆法的方法改变成递推求解。题目还有一个易错点即变量类型，可以由序列和的范围知最好采用long long型。<br>&emsp;&emsp;递推求解的代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MINN = <span class="number">-1e6</span><span class="number">-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> arr[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[MAXN];<span class="comment">//记录以输入每个元素结尾的最大字符和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maximum = MINN;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span>)dp[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span>    dp[i]  = <span class="built_in">max</span>(arr[i],dp[i<span class="number">-1</span>]+arr[i]);</span><br><span class="line">maximum =<span class="built_in">max</span>(maximum,dp[i]); <span class="comment">//对递归求解的优化部分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maximum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;arr[i]);</span><br><span class="line">&#125;<span class="comment">//输入参数模块，基操</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="built_in">func</span>(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一、最大连续子序列和-1"><a href="#一、最大连续子序列和-1" class="headerlink" title="一、最大连续子序列和"></a>一、最大连续子序列和</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;动态规划算法&quot;&gt;&lt;a href=&quot;#动态规划算法&quot; class=&quot;headerlink&quot; title=&quot;动态规划算法&quot;&gt;&lt;/a&gt;动态规划算法&lt;/h1&gt;&lt;h2 id=&quot;一、动态规划简介&quot;&gt;&lt;a href=&quot;#一、动态规划简介&quot; class=&quot;headerlink&quot; title=&quot;一、动态规划简介&quot;&gt;&lt;/a&gt;一、动态规划简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;与分治法类似，即将待求解问题分解为若干子问题，先求解子问题，再由子问题的解得到原问题的解。</summary>
    
    
    
    <category term="Leetcode刷题笔记" scheme="http://www.liuxinlu.xyz/categories/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DP" scheme="http://www.liuxinlu.xyz/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>重配爵士和声教程（一）</title>
    <link href="http://www.liuxinlu.xyz/2021/01/28/%E9%87%8D%E9%85%8D%E5%92%8C%E5%A3%B0%E6%95%99%E7%A8%8B/"/>
    <id>http://www.liuxinlu.xyz/2021/01/28/%E9%87%8D%E9%85%8D%E5%92%8C%E5%A3%B0%E6%95%99%E7%A8%8B/</id>
    <published>2021-01-27T17:59:09.000Z</published>
    <updated>2021-01-28T04:49:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何重配和声（笔记）"><a href="#如何重配和声（笔记）" class="headerlink" title="如何重配和声（笔记）"></a>如何重配和声（笔记）</h1><p>注：重配和声  =  和弦替代</p><p>重配和声被用于：<span id="more"></span></p><ul><li>让一首歌爵士化，即丰富其和声，让它的结构复杂</li><li>使歌曲更富有个人色彩</li></ul><p>歌曲的普遍结构=旋律线 + 和声进行，重配和声包括改变歌曲的旋律线和和声，此改变要基于一定的规则和概念。</p><h2 id="重配和声分为以下两个方面："><a href="#重配和声分为以下两个方面：" class="headerlink" title="重配和声分为以下两个方面："></a>重配和声分为以下两个方面：</h2><ol><li>和弦<ol><li>旋律和和弦之间相互作用要合理</li><li>取决于和弦的种类</li><li>基音必须是所选和弦中的一个可用音</li></ol></li><li>结构（包括和弦结构和低音线条）<ol><li>不受和弦种类的影响</li><li>结构必须合理   </li></ol></li></ol><p><strong>重配和弦的步骤</strong></p><ol><li>找出基音</li></ol><p><img src="https://tva4.sinaimg.cn/large/0083jUChgy1gn2sncftjwj30dz07n76q.jpg" alt="avatar"></p><p>上图中红圈中圈出来的是基音</p><h2 id="和声"><a href="#和声" class="headerlink" title="和声"></a>和声</h2><ol><li>改变和弦或者基音以确保基音是一个可接受和弦音</li><li>可接受和弦音加强了和声的质量，提升了歌曲的一致性</li><li>和弦音按照其在和弦中的功能可以被分成“弱和声效果音（以下简称弱效音）”，“强和声效果音（以下简称强效音）”，“爵士效果音（以下简称爵味音）”和“不和谐音”。<ul><li>根音和纯五度是弱效音</li><li>三音，七音和增减无毒音是强效音. </li></ul></li></ol><p>下表以C的所有和弦为例，列出了十二音体系中的所有音对于和弦的和声特性：</p><p><img src="https://tvax2.sinaimg.cn/large/0083jUChgy1gn2sp9vlm6j30jt0iwdj1.jpg" alt=""></p><p>下表是当基音为C时，所有根音的所有和弦对于它的和声效果。<br><img src="https://tva4.sinaimg.cn/large/0083jUChgy1gn2spuao5ej30lz08wt9h.jpg" alt=""></p><p><a href="http://www.thejazzpianosite.com/jazz-piano-lessons/jazz-reharmonization/how-to-reharmonize-a-song/（图源）">http://www.thejazzpianosite.com/jazz-piano-lessons/jazz-reharmonization/how-to-reharmonize-a-song/（图源）</a></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ol><li>考虑结构的时候可以忽略和弦的种类</li><li>使一个和弦/低音通过结构化的方式向下一个移动，具体如下：<ul><li>固定的音程间隔</li><li>沿着特定调性</li><li>沿着旋律线条</li></ul></li></ol><p><strong>固定间隔的种类</strong></p><p>音程    和弦进行举例<br>半音阶(Chromatic)    Eb7 - D7 - Db7 - CMaj7<br>全音阶    F#7 - E7 - Dm7 - CMaj7<br>小三度    Am7 - F#7 - Eb7 - CMaj7<br>大三度(Coltrane)    CMaj7 - AMaj7 - EMaj7 - CMaj7<br>纯四度（逆时针五度圈）    EbMaj7 - BbMaj7 - FMaj7 - CMaj7<br>三全音    F#7 - C7 - F#7 - C7<br>纯五度（顺时针五度圈）    A7 - Dm7 - G7 - CMaj7<br>so on…(上行下行皆可)    </p><p><strong>基于特定调式</strong></p><p>音程    和弦进行<br>固定音程    F7 - E7 - D7 - CMaj7<br>B7 - G7 - E7 - C7<br>五度圈    F7 - B7 - E7 - A7 - D7 - G7 - C7</p><h2 id="低音线条"><a href="#低音线条" class="headerlink" title="低音线条"></a>低音线条</h2><ul><li>可以通过转位和弦创造平滑的低音线条，使得低音不出现跳进</li><li>低音线条同样遵循结构的规则 - 固定的音程间隔，沿着某种调式，沿着旋律线条</li><li>低音线条和和弦的根音可以根据不同的方式进行，只要他们都遵循特定的结构且合理即可</li></ul><p><img src="https://tva4.sinaimg.cn/large/0083jUChgy1gn2sr2y1zjj30eb08241t.jpg" alt=""></p><h2 id="其他规则-注意事项"><a href="#其他规则-注意事项" class="headerlink" title="其他规则/注意事项"></a>其他规则/注意事项</h2><ul><li>通过选择和弦来增加或者减少紧张感<ul><li>增加紧张感——高阶延申音和变化音</li><li>减少紧张感——3音、7音和低阶延申音（如属9音）</li></ul></li><li>在旋律音时值长且重复多次时，可以改变和弦</li><li>如果和声进行有很强的结构性的时候，可以选择旋律音是弱效音的和弦</li><li>如果有旋律音是强效音的时候，那么结构这方面可以稍微弱化一点</li><li>如果旋律音是一串连续音符，找不出明显的基音，结构这时候比和声重要</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;如何重配和声（笔记）&quot;&gt;&lt;a href=&quot;#如何重配和声（笔记）&quot; class=&quot;headerlink&quot; title=&quot;如何重配和声（笔记）&quot;&gt;&lt;/a&gt;如何重配和声（笔记）&lt;/h1&gt;&lt;p&gt;注：重配和声  =  和弦替代&lt;/p&gt;
&lt;p&gt;重配和声被用于：</summary>
    
    
    
    <category term="和声学学习" scheme="http://www.liuxinlu.xyz/categories/%E5%92%8C%E5%A3%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="和声学" scheme="http://www.liuxinlu.xyz/tags/%E5%92%8C%E5%A3%B0%E5%AD%A6/"/>
    
    <category term="爵士和弦" scheme="http://www.liuxinlu.xyz/tags/%E7%88%B5%E5%A3%AB%E5%92%8C%E5%BC%A6/"/>
    
    <category term="乐理" scheme="http://www.liuxinlu.xyz/tags/%E4%B9%90%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>歌曲配爵士和弦学习笔记</title>
    <link href="http://www.liuxinlu.xyz/2021/01/28/%E6%AD%8C%E6%9B%B2%E9%85%8D%E7%88%B5%E5%A3%AB%E5%92%8C%E5%BC%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.liuxinlu.xyz/2021/01/28/%E6%AD%8C%E6%9B%B2%E9%85%8D%E7%88%B5%E5%A3%AB%E5%92%8C%E5%BC%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-27T17:31:45.000Z</published>
    <updated>2021-01-27T18:11:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何让一首歌改成爵士风格（一）"><a href="#如何让一首歌改成爵士风格（一）" class="headerlink" title="如何让一首歌改成爵士风格（一）"></a>如何让一首歌改成爵士风格（一）</h1><p>——油管学习笔记，由于年代久远，原视频链接找不到了<br><span id="more"></span></p><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol><li>延申和弦</li><li>更改和弦音</li><li>插入经过和弦</li><li>选择合适的和声声效</li><li>替代和弦（重编和弦）<ol><li>基础的替代</li><li>普遍规则</li></ol></li><li>加入旋律装饰——填充音，和声，经过音，颤音，即兴等等</li></ol><p><img src="https://tvax1.sinaimg.cn/large/0083jUChgy1gn2s55pze5j30fh08n0vx.jpg" alt="avatar"></p><p>上图以Beatles的经典歌曲Let it Be 为例，列出了它的原始和弦和主旋律音</p><h2 id="找出歌曲每小节的主旋律音的方法（后简称为基音）"><a href="#找出歌曲每小节的主旋律音的方法（后简称为基音）" class="headerlink" title="找出歌曲每小节的主旋律音的方法（后简称为基音）"></a>找出歌曲每小节的主旋律音的方法（后简称为基音）</h2><ul><li>每小节第一个音</li><li>重拍上出现的音</li><li>时值长的音</li><li>重复的音</li></ul><p><img src="https://tva3.sinaimg.cn/large/0083jUChgy1gn2s62s2jlj30ff08hgox.jpg" alt="avatar"></p><p>将所有原本的和弦升级成为七和弦</p><p><img src="https://tva3.sinaimg.cn/large/0083jUChgy1gn2s7z2ir9j30fe08nq6q.jpg" alt="avatar"></p><p>将七和弦继续升级，使其和声效果更加丰富<br><img src="https://tvax4.sinaimg.cn/large/0083jUChgy1gn2s9im7j9j30f408f410.jpg" alt="avatar"></p><p>变化音规则：</p><ul><li>可以变化该和弦中的任何音除了基音</li></ul><p><img src="https://tvax1.sinaimg.cn/large/0083jUChgy1gn2saczhu3j30ev08eadw.jpg" alt="avatar"><br><img src="https://tvax3.sinaimg.cn/large/0083jUChgy1gn2sawhmpyj30ey08ftbu.jpg" alt="avatar"></p><p>以上是基于原有和弦进行的和弦编配，整体框架还是在原有和弦的基础上。<br>——————————————————————分割线——————————————————————————<br>以下是重配和弦，相当于完全不看原有和弦，对旋律线重新配爵士和声。</p><h2 id="重配和弦法则——为什么只有特定的和弦可以作为替代和弦"><a href="#重配和弦法则——为什么只有特定的和弦可以作为替代和弦" class="headerlink" title="重配和弦法则——为什么只有特定的和弦可以作为替代和弦"></a>重配和弦法则——为什么只有特定的和弦可以作为替代和弦</h2><ul><li>重配和弦完全取决于每小节的旋律基音（以下简称基音）</li><li>普遍法则：可以改变一个和弦中任何音，除了基音</li><li>可以改变3rd、7rd和根音，进而改变了和弦的质量和调性</li><li>必须理解‘可接受的和声’以及‘可用紧张感’</li></ul><p><img src="https://tva1.sinaimg.cn/large/0083jUChgy1gn2sbeyizyj30f808eq89.jpg" alt="avatar"></p><p>以上以C的几种和弦为例，列举出了每个和弦音的和声作用（包括弱和音，强和音，爵士合音，以及不和谐音）</p><p><img src="https://tvax2.sinaimg.cn/large/0083jUChgy1gn2scebl9yj30eq08bmzz.jpg" alt="avatar"></p><p>以上是当基音为G时，可以选择的重配和弦的种类。可以看见，基本上12音体系中的所有音都可以作为重配和弦的根音。而该和弦是否合适主要取决于上表，可以根据它设计和弦重配算法算法。</p><h2 id="重配和弦步骤"><a href="#重配和弦步骤" class="headerlink" title="重配和弦步骤"></a>重配和弦步骤</h2><ol><li>选择任何一个对于基音的可用和弦</li><li>结构化地进行到相邻的和弦<ol><li>半音进行，例如E7进行到EbMaj7</li><li>全音进行，如从Em7到Dm7</li><li>五度圈进行，如从B7到Em7</li></ol></li><li>选择紧张度交替进行的和声进行<ol><li>增加紧张度，高阶延申音和变化音（如b13）</li><li>降低紧张度，3rd，7th音以及低阶延申音和变化音（如9th）</li></ol></li></ol><p><img src="https://tva3.sinaimg.cn/large/0083jUChgy1gn2sd0ii2ij30ew088dju.jpg" alt="avatar"></p><p>Let it Be重配和声后的其中一个版本<br><img src="https://tva2.sinaimg.cn/large/0083jUChgy1gn2sdlkp4bj30et08btbj.jpg" alt="avatar"></p><p>复杂和声的和弦音功能表</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;如何让一首歌改成爵士风格（一）&quot;&gt;&lt;a href=&quot;#如何让一首歌改成爵士风格（一）&quot; class=&quot;headerlink&quot; title=&quot;如何让一首歌改成爵士风格（一）&quot;&gt;&lt;/a&gt;如何让一首歌改成爵士风格（一）&lt;/h1&gt;&lt;p&gt;——油管学习笔记，由于年代久远，原视频链接找不到了&lt;br&gt;</summary>
    
    
    
    <category term="和声学学习" scheme="http://www.liuxinlu.xyz/categories/%E5%92%8C%E5%A3%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="和声学" scheme="http://www.liuxinlu.xyz/tags/%E5%92%8C%E5%A3%B0%E5%AD%A6/"/>
    
    <category term="爵士和弦" scheme="http://www.liuxinlu.xyz/tags/%E7%88%B5%E5%A3%AB%E5%92%8C%E5%BC%A6/"/>
    
    <category term="乐理" scheme="http://www.liuxinlu.xyz/tags/%E4%B9%90%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题笔记-2-最长回文子串</title>
    <link href="http://www.liuxinlu.xyz/2021/01/28/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-2/"/>
    <id>http://www.liuxinlu.xyz/2021/01/28/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-2/</id>
    <published>2021-01-27T16:00:22.000Z</published>
    <updated>2021-01-28T05:17:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最长回文子串-TENET"><a href="#最长回文子串-TENET" class="headerlink" title="最长回文子串(TENET)"></a>最长回文子串(TENET)</h1><p>&emsp;&emsp;题目描述：给你一个字符串 s，找到 s 中最长的回文子串。<span id="more"></span>1 &lt;= s.length &lt;= 1000且 s 仅由数字和英文字母（大写和/或小写）组成。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>&emsp;&emsp;看到题目的第一眼不难想到暴力解法，如果字符串长度为t的话，那么从头到尾遍历所有的字符串时间复杂度为O($t^2$),而此情况下判断字符串是否回文的最小时间复杂度为O($t$),所以总时间复杂度为O($t^3$),由于y最大为1000，因此此方法超时。<br>&emsp;&emsp;之后想到一种去除冗余遍历的方式，如果以字符串元素s[i]为中点，然后以中点向外发散式的遍历字符串。这样遍历有一种好处，那就是如果扩散到外围某个元素发现此时不回文了，那么此时可以中止向外扩散。<br>&emsp;&emsp;但是有一个问题，中心扩散有两种方式。若用mid指代中心元素位置，一种有奇数个元素，即mid在字符串正中间。第二种是有偶数个元素，那么mid处于中心偏右或者中心偏左的位置。因此要分情况讨论，下面我们默认mid只能处于中心偏右。<br>&emsp;&emsp;采用了这种算法后，对于是否回文的判断也简化了，对于同一个mid，是否回文只需判断最外圈层的元素是否对称，即时间复杂度为O(1),总时间复杂度降为O($n^2$)了。<br>具体代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><span class="comment">//时间复杂度O(n^2)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Ishuiwen</span><span class="params">(string x)</span></span>&#123;<span class="comment">//此函数用于判断字符串是否回文</span></span><br><span class="line">        <span class="keyword">if</span>(x[<span class="number">0</span>]==x[x.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用中心扩散法来减少计算量</span></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;<span class="comment">//中心元素</span></span><br><span class="line">        <span class="keyword">int</span> front;<span class="comment">//扩散字符串的头指针</span></span><br><span class="line">        <span class="keyword">int</span> halflength;<span class="comment">//由于是中心扩散，所以定义一个半长</span></span><br><span class="line">        <span class="keyword">int</span> length;<span class="comment">//当前遍历字符串总长度</span></span><br><span class="line">        string ans=s.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//答案字符串</span></span><br><span class="line">        <span class="keyword">int</span> anslength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(mid = <span class="number">0</span>;mid&lt;s.<span class="built_in">size</span>();mid++)&#123;</span><br><span class="line">            halflength = <span class="number">0</span>;</span><br><span class="line">            front = mid;</span><br><span class="line">            length = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">Ishuiwen</span>(s.<span class="built_in">substr</span>(front,length)))&#123;<span class="comment">//第一种情况，以mid为中心</span></span><br><span class="line">                front = mid-halflength;</span><br><span class="line">                length = <span class="number">2</span>*halflength+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[front]==s[front+length<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(length&gt;anslength)&#123;</span><br><span class="line">                        ans = s.<span class="built_in">substr</span>(front, length);</span><br><span class="line">                        anslength = length;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">break</span>;</span><br><span class="line">                halflength++;</span><br><span class="line">            &#125;</span><br><span class="line">            halflength = <span class="number">0</span>;</span><br><span class="line">            front = mid;</span><br><span class="line">            length = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">Ishuiwen</span>(s.<span class="built_in">substr</span>(front,length)))&#123;<span class="comment">//第二种情况，mid为中心右侧</span></span><br><span class="line">                front = mid-halflength<span class="number">-1</span>;</span><br><span class="line">                length = <span class="number">2</span>*(halflength+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(s[front]==s[front+length<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(length&gt;anslength)&#123;</span><br><span class="line">                        ans = s.<span class="built_in">substr</span>(front, length);</span><br><span class="line">                        anslength = length;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">break</span>;</span><br><span class="line">                halflength++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然而此发超时，因此还需进一步去除代码冗余，后经分析得知，判断时候冗余的函数 bool Ishuiwen(string x) 可以直接用一个判断语句代替。  </p><pre><code>if(s[front]==s[front+length-1])</code></pre><p>&emsp;&emsp;再次运行代码没有超时。此题还可以用动态规划的方法，目前未掌握。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;最长回文子串-TENET&quot;&gt;&lt;a href=&quot;#最长回文子串-TENET&quot; class=&quot;headerlink&quot; title=&quot;最长回文子串(TENET)&quot;&gt;&lt;/a&gt;最长回文子串(TENET)&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;题目描述：给你一个字符串 s，找到 s 中最长的回文子串。</summary>
    
    
    
    <category term="Leetcode刷题笔记" scheme="http://www.liuxinlu.xyz/categories/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="http://www.liuxinlu.xyz/tags/C/"/>
    
    <category term="leetcode" scheme="http://www.liuxinlu.xyz/tags/leetcode/"/>
    
    <category term="string" scheme="http://www.liuxinlu.xyz/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-1-回文数</title>
    <link href="http://www.liuxinlu.xyz/2021/01/27/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.liuxinlu.xyz/2021/01/27/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-27T14:01:24.000Z</published>
    <updated>2021-01-28T04:49:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><p>&emsp;&emsp;1. 题目描述：判断一个整数是否是<strong>回文数</strong>。<span id="more"></span>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。  </p><p>&emsp;&emsp;2. 题目分析：本题关键在于编写求回文数函数，此题难度不大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//计算回文数函数</span></span><br><span class="line">        <span class="keyword">long</span> ans =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!= <span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans*<span class="number">10</span>;</span><br><span class="line">            ans = ans+x%<span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">reverse</span>(x)==x)   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;回文数&quot;&gt;&lt;a href=&quot;#回文数&quot; class=&quot;headerlink&quot; title=&quot;回文数&quot;&gt;&lt;/a&gt;回文数&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;1. 题目描述：判断一个整数是否是&lt;strong&gt;回文数&lt;/strong&gt;。</summary>
    
    
    
    <category term="Leetcode刷题笔记" scheme="http://www.liuxinlu.xyz/categories/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="http://www.liuxinlu.xyz/tags/C/"/>
    
    <category term="leetcode" scheme="http://www.liuxinlu.xyz/tags/leetcode/"/>
    
  </entry>
  
</feed>
